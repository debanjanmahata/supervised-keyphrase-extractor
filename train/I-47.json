{"abstract": "The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms .Still , these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular , pre-defined abstractions .The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms both , organizational and communicative , share a common semantic core .In the realm of software architectures , the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions .Furthermore , the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions .The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms .", "id": "I-47", "reader_keywords_stem": ["oper semant", "multiag interact", "institut framework", "pre-defin abstract", "organiz and commun abstract", "softwar architectur", "connector-base model of multi-agent interact", "multi-agent interact connector-base model", "formal execut semant", "organiz program languag", "softwar connector", "social interact", "structur oper semant"], "reader_keywords": ["operational semantics", "multiagent interaction", "institutional framework", "pre-defined abstraction", "organizational and communicative abstraction", "software architecture", "connector-based model of multi-agent interaction", "multi-agent interaction connector-based model", "formal execution semantics", "organizational programming language", "software connector", "social interaction", "structural operational semantics"], "introduction": "The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in thedevelopment of large scale , open systems , has become one of its major assets over the last few years 26 , 24 , 15 .Particularly , the organizational or social stance advocated by institutional frameworks 2 and most multi-agent system MAS methodologies 26 , 10 , provides an excellent basis to deal with the complexity and dynamism of the interactions among system components .This approach has resulted in a wide spectrum of organizational and communicative abstractions , such as institutions , normative positions , power relationships , organizations , groups , scenes , dialogue games , communicative actions CAs , etc. , to effectively model the interaction space of MAS .This wealth of computational abstractions has found currency in several programming frameworks and software platforms AMELI 9 , MadKit 13 , INGENIAS toolkit 18 , etc. , which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism 14 , and minimize the gap between organizational metamodels and target implementation languages .Still , these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular , pre-defined abstractions .The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms both , organizational and communicative , share a common semantic core .This paper thus focuses on the fundamental building blocks of multi-agent interactions : those which may be composed , extended or refined in order to define more complex organizational or communicative types of interactions .Its first goal is to carry out a principled analysis of multiagent interactions , departing from general features commonly ascribed to agent-based computing : autonomy , situatedness and sociality 26 .To approach this issue , we draw on the notion of connector , put forward within the field of software architectures 1 , 17 .The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components , i.e. agents , attempting to identify their essential structure .Furthermore , the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent or social interactions .Structural Operational Semantics SOS 21 , a common technique to specify the operational semantics of programming languages , is used for this purpose .The paper is structured as follows : first , the major entities and relationships which constitute the structure of social interactions are introduced .Next , the dynamics of social interactions will show how these entities and relationships evolve .Last , relevant work in the literature is discussedwith respect to the proposal , limitations are addressed , and current and future work is described .", "title": "Operational Semantics of Multiagent Interactions", "combined_keywords": ["operational semantics", "multiagent interaction", "institutional framework", "pre-defined abstraction", "organizational and communicative abstraction", "software architecture", "connector-based model of multi-agent interaction", "multi-agent interaction connector-based model", "formal execution semantics", "organizational programming language", "software connector", "social interaction", "structural operational semantics"], "author_keywords": ["social interaction", "software connector", "operational semantics"], "method": "From an architectural point of view , interactions between software components are embodied in software connectors : first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour 1 .The roles of a connector represent its participants , such as the caller and callee roles of an RPC connector , or the sender and receiver roles in a message passing connector .The attachment operation binds a component to the role of a given connector .The analysis of social interactions introduced in this section gives rise to a new kind of social connector .It refines the generic model in several respects , attending to the features commonly ascribed to agent-based computing :Besides agents , resources and social protocols , two other kinds of entities are of major relevance in our analysis of social interactions : actions , which represent the way in which agents alter the environmental and social state of the interaction ; and events , which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources .In the following , we describe the basic entities involved in social interactions .Each kind of entity T will be specified as a record type T g l1 : T1 , ... ln : Tn , possibly followed by a number of invariants , definitions , and the actions affecting their state .Instances or values v of a record type T will be represented as v = v1 , ... , vn : T .The type SetT represents a collection of values drawn from type T .The type QueueT represents a queue of values v : T waiting to be processed .The value v in the expression v | : Queue T represents the head of the queue .The type Enum v1 , ... , vn 1Note that we think of the autonomy feature in a relative , rather than absolute , perspective .Basically , this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts , e.g. in their interactions through human-user interfaces .This conceptualization of agenthood resembles the way in which objects are understood in CORBA : as any kind of software component C , Prolog , Cobol , etc. attached to an ORB .represents an enumeration type whose values are v1 , ... , vn .Given some value v : T , the term vl refers to the value of the field l of a record type T. Given some labels l1 , l2 , ... , the expression vl1 , l2 , ... is syntactic sugar for vl1 l2 ... .The special term nil will be used to represent the absence of proper value for an optional field , so that vl = nil will be true in those cases and false otherwise .The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses .Social interactions shall be considered as composite connectors 17 , structured in terms of a tree of nested subinteractions .Let 's consider an interaction representing a university course e.g. on data structures .On the one hand , this interaction is actually a complex one , made up of lower-level interactions .For instance , within the scope of the course agents will participate in programming assignment groups , lectures , tutoring meetings , examinations and so on .Assignment groups , in turn , may hold a number of assignment submissions and test requests interactions .A test request may also be regarded as a complex interaction , ultimately decomposed in the atomic , or bottom-level interactions represented by communicative actions e.g. request , agree , refuse , ... .On the other hand , courses are run within the scope of a particular degree e.g. computer science , a higher-level interaction .Traversing upwards from a degree to its ancestors , we find its faculty , the university and , finally , the multi-agent community or agent society .The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .The organizational and communicative interaction types identified above clearly differ in many ways .However , we may identify four major components in all of them : the participating agents , the resources that agents manipulate , the protocol regulating the agent activities and the subinteraction space .Accordingly , we may specify the type I of social interactions , ranged over by the meta-variable i , as follows :where the member and environment fields represent the agents A and local resources R participating in the interaction ; the sub-interaction field , its set of inner interactions ; and the protocol field the rules that govern the interaction P .The event channel , to be described in the next section , allows the dispatching of local events to external interactions .The context of some interaction is defined as its super-interaction def .1 , so that the context of the toplevel interaction is nil .The type SI g Enum open , closing , closed represents the possible execution states of the interaction .Any interaction , but the top-level one , is set up within the context of another interaction by an initiator agent .The initiator is 2In the context of this application , a one-to-one mapping between human users and software components attached to the community as agents would be a right choice .thus a mandatory feature for any interaction different to the community inv .2 .The life-cycle of the interaction begins in the open state .Its sets of agent and resource participants , initially empty , vary as agents join and leave the interaction , and as they create and destroy resources from its local environment .Eventually , the interaction may come to an end according to the protocol 's rules , or be explicitly closed by some agent , thus prematurely disabling the activity of its participants .The transient closing state will be described in the next section .Components attach themselves as agents in social interactions with the purpose of achieving something .The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .The types of agents participating in a given interaction are primarily identified from their purposes .For instance , students are those agents participating in a course who purport to obtain a certificate in the course 's subject .Other members of the course include lecturers and teaching assistants .The type A of agents , ranged over by meta-variable a , is defined as follows :where the purpose is represented as a well-formed boolean formula , of a generic type F , which evaluates to true if the purpose is satisfied and false otherwise .The context of some agent is defined as the interaction in which it participates def .3 .The type SA g Enum playing , leaving , succ , unsuc represents the execution state of the agent .Its life-cycle begins in the playing state when its player agent joins the interaction , or some software component is attached as an agent to the multi-agent system in this latter case , the player value is nil .The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played def .4 , 5 4 .An agent may play roles at interactions within or outside the scope of its context .For instance , students of a course are played by student agents belonging to the undergraduate degree , whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree both , the department and the Ph.D. degrees , are modelled as sub-interactions of the faculty .Components will normally attempt to perform different actions e.g. to set up sub-interactions in order to satisfy their purposes within some interaction .Moreover , components need to be aware of the current state of the interaction , so that they will also be capable of observing certain events from the interaction .Both , the visibility of the interaction 3Thus , it may or may not correspond to actual internal `` goals '' or `` intentions '' of the component .4Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified .and the attempts of members , are subject to the rules governing the interaction .The attempts and events fields of the agent structure represent the queues of attempts to execute some actions ACT , and the events E received by the agent which have not been observed yet .An agent may update its event queue by seeing the state of some entity of the community .The last field of the structure represents the obligations O of agents , to be described later .Eventually , the participation of some agent in the interaction will be over .This may either happen when certain conditions are met specified by the protocol rules , or when the agent takes the explicit `` decision '' of leaving the interaction .In either case , the final state of the agent will be successful if its purpose was satisfied ; unsuccessful otherwise .The transient leaving state will be described in the next section .Resources are software components which may represent different types of non-autonomous informational or computational entities .For instance , objectives , topics , assignments , grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction .Students may also create programs to satisfy the requirements of some assignment .Other types of computational resources put at the disposal of students by teachers include compilers and interpreters .The type R of resources , ranged over by meta-variable r , can be specified by the following record type :Essentially , resources can be regarded as objects deployed in a social setting .This means that resources are created , accessed and manipulated by agents in a social interaction context def .6 , according to the rules specified by its protocol .The mandatory feature creator represents the agent who created this resource .Moreover , resources may have owners .The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocol 's rules that govern the interaction of agents and the environment .Members may gain ownership of some resource by taking it , and grant ownership to other agents by giving or sharing their own properties .For instance , the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students .The last operations feature represents the interface of the resource , consisting of a set of operations .A resource is structured around several public operations that participants may invoke , in accordance to the rules specified by the interaction 's protocol .The set of operations of a resource makes up its interface .The protocol of any interaction is made up of the rules which govern its overall state and dynamics .The present specification abstracts away the particular formalism used to specify these rules , and focuses instead on several requirements concerning the structure and interface of protocols .Accordingly , the type P of protocols , ranged over by metaWe demand from protocols four major kinds of functions .Firstly , protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction e.g. its members , the environment , etc. through the execution of some action e.g. join , create , etc. .Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose .Corresponding rules , encapsulated by the empowered function field , shall allow to determine whether some agent is capable to perform a given action over the interaction .Empowerments may only be exercised under certain circumstances that permissions specify .Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not cf. permitted field .For instance , the course 's protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the course 's subject , and own the certificates corresponding to its prerequisite subjects .Permission rules , in turn , specify that those students may only join the course in the admission stage .Hence , even if some student has paid the fee , the attempt to join the course will fail if the course has not entered the corresponding stage6 .Secondly , protocols shall allow to determine the obligations of agents towards the interaction .Obligations represent a normative device of social enforcement , fully compatible with the autonomy of agents , used to bias their behaviour in a certain direction .These kinds of rules shall allow to determine whether some agent must perform an action of a given type , as well as if some obligation was fulfilled , violated or needs to be revoked .The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated .Moreover , it returns for each agent a collection of events representing the changes in the obligation set .For instance , the course 's protocol establishes that members of departments must join the course as teachers whenever they are assigned to the course 's subject .Thirdly , the protocol shall allow to specify monitoring rules for the different events originating within the interaction .Corresponding rules shall establish the set of agents that must be awared of some event .For instance , this func5The formalization assumes that protocol 's functions implicitly recieve as input the interaction being regulated .6The hasPaidFee relationship between degree students and subject resources is represented by an additional , application-dependent field of the agent structure for this kind of roles .Similarly , the admission stage is an additional boolean field of the structure for school interactions .The generic types I , A , R and P are thus extendable .tionality is exploited by teachers in order to monitor the enrollment of students to the course .Last , the protocol shall allow to control the state of the interaction as well as the states of its members .Corresponding rules identify the conditions under which some interaction will be automatically finished , and whether the participation of some member agent will be automatically over .Thus , the function field finish returns true if the regulated interaction must finish its execution .If so happens , a well-defined set of protocols must ensure that its sub-interactions and members are finished as well inv .8,9 .Similarly , the function over returns true if the participation of the specified member must be over .Well-formed protocols must ensure the consistency between these functions across playing roles inv .10 7 .For instance , the course 's protocol establishes that the participation of students is over when they gain ownership of the course 's certificate or the chances to get it are exhausted .It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation .The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions .This section focuses on the dynamics resulting from a particular kind of external action : the attempt of some component , attached to the community as an agent , to execute a given internal action .The description of other external actions concerning agents e.g. observe the events from its event queue , enter or exit from the community and resources e.g. a timer resource may signal the pass of time will be skipped .The processing of some attempt may give rise to changes in the scope of the target interaction , such as the instantiation of new participants agents or resources or the setting up of new sub-interactions .These resulting events may cause further changes in the state of other interactions the target one included , namely , in its execution state as well as in the execution state , obligations and visibility of their members .This section will also describe the way in which these events are processed .The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously .Due to lack of space , we only include some of the operational rules that formalise the execution semantics .An attempt is defined by the structure ATT g perf : A , act : ACT , where the performer represents the agent in charge of executing the specified action .This action is intended to alter the state of some target interaction possibly , the performer 's context itself , and notify a collection of addressees of the changes resulting from a successful execution .Accordingly , the type ACT of actions , ranged over by meta-variable \u03b1 , is specified as follows :7The close and leave actions update the finish and over function fields as explained in the next section .Additional actions , such as permit , forbid , empower , etc. , to update other protocol 's fields are yet to be identified in future work .where : the performer is formally defined as the agent who stores the action in its queue of attempts , and the state field represents the current phase of processing .This process goes through four major phases , as specified by the enumeration type SACT Enum emp , perm , exec : empowerment checking , permission checking and action execution , described in the sequel .The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer .As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction .If this condition is not met , the attempt will simply be ignored .Moreover , the performer agent must be in the playing state this pre-condition is also required for any rule concerning the processing of attempts .If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage .For instance , when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached , the empowerment rules of the course interaction are checked .If the degree student has passed the course 's prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution .The processing of the action resumes when the possible preceding actions in the performer 's queue of attempts are fully processed and removed from the queue .Moreover , there should be no pending events to be processed in the interaction , for these events may cause the member or the interaction to be finished as will be shortly explained in the next sub-section .If these conditions are met the permissions to execute the given action and notify the specified addressees are checked e.g. it will be checked whether the student paid the fee for the course 's subject .If the protocol of the target interaction grants permission , the processing of the attempt moves to the action execution stage rule 2 .Otherwise , the action is discharged and removed from the queue .Unlike unempowered attempts , a forbidden one will cause an event to be generated and transfered to the event channel for further processing .8Labels of record instances are omitted to allow for more compact specifications .Moreover , note that record updates in `` where '' clauses only affect the specified fields .The transitions fired in this stage are classified according to the different types of actions to be executed .The intended effects of some actions may directly be achieved in a single step , while others will required an indirect approach and possibly several execution steps .Actions of the first kind are `` constructive '' ones such as set up and join .The second group of actions include those , such as close and leave , whose effects are indirectly achieved by updating the interaction protocol .As an example of constructive action , let 's consider the execution of a set up action , whose type is defined as follows9 :where the new field represents the new interaction to be initiated .Its sets of participants agents and resources and sub-interactions must be empty inv .13 and its state must be open inv .14 .The setting up of the new interaction may thus affect its protocol and possible application-dependent fields e.g. the subject of a course interaction .According to rule 3 , the outcome of the execution is threefold : firstly , the performer 's attempt queue is updated so that the executing action is removed ; secondly , the new interaction is added to the target 's set of sub-interactions moreover , its initiator field is set to the performer agent ; last , the event representing this change which includes a description of the change , the agent that caused it and the action performed is inserted in the output port of the target 's event channel .Let 's consider now the case of a close action .This action represents an attempt by the performer to force some interaction to finish , thus bypassing its current protocol rules those concerning the finish function .The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .Accordingly , we may specify this type of action as follows :where the inherited target field represents the interaction to be closed which must be open and different to the topinteraction , according to invariants 15 and 16 and the new 9The resulting type consists of the fields of the ACT record extended with an additional new field .10This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire , permit , forbid , etc. .update field represents a proper higher-order function to update the target 's protocol inv .17 .The transition which models the execution of this action , specified by rule 4 , defines two effects in the target interaction : its protocol is updated and the event representing this change is inserted in its output port .This event will actually trigger the closing process of the interaction as described in the next subsection .The processing of events is encapsulated in the event channels of interactions .Channels , ranged over by meta-variable c , are defined by two input and output ports , according to the following definition :The output port stores and processes the events originated within the scope of the channel 's interaction .Its first purpose is to dispatch the local events to the agents identified by the protocol 's monitoring function .Moreover , since these events may influence the results of the finishing , over and obligation functions of certain protocols , they will also be dispatched to the input ports of the interactions identified through a dispatching function whose invariants will be explained later on .Thus , input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .Accordingly , the processing of some event goes through four major stages : event dispatching , interaction state update , member state update and obligations update .The first one takes place in the output port of the interaction in which the event originated , whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched .The processing of some event stored in the output port is triggered when all its preceding events have been dispatched .As a first step , the auxiliary int and ag fields are initialised 11Alternatively , we may have assumed that interactions are fully aware of any change in the multi-agent community .In this scenario , interactions would trigger themselves without requiring any explicit notification .On the contrary , we adhere to the more realistic assumption of limited awareness .with the returned values of the dispatching and protocol 's monitoring functions , respectively rule 5 .Then , additional rules simply iterate over these collections until all agents and interactions have been notified i.e. , both sets are empty .Last , the event is removed from the queue and the auxiliary fields are re-set to nil .The dispatching function shall identify the set of interactions possibly , empty that may be affected by the event which may include the channel 's interaction itself 12 .For instance , according to the finishing rule of university courses mentioned in the last section , the event representing the end of the admission stage , originated within the scope of the school interaction , will be dispatched to every course of the school 's degrees .Concerning the monitoring function , according to invariant 11 of protocols , if the event is generated as the result of an action performance , the agents to be notified will include the performer and addressees of that action .Thus , according to the monitoring rule of university courses , if a student of some degree joins a certain course and specifies a colleague as addressee of that action , the course 's teachers and itself will also be notified of the successful execution .Input port activity is triggered when a new event is received .Irrespective of the kind of incoming event , the first processing action is to check whether the channel 's interaction must be finished .Thus , the dispatching of the finish event resulting from a close action inv .18 serves as a trigger of the closing procedure .If the interaction has not to be finished , the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members .Otherwise , we can consider two possible scenarios .In the first one , the interaction has no members and no sub-interactions .In this case , the interaction can be inmediately closed down .As rule 6 shows , the interaction is closed , removed from the context 's set of sub-interactions and a closed event is inserted in its output channel .According to invariant 22 , this event will be later inserted to its input channel to allow for further treatment .In the second scenario , the interaction has some member or sub-interaction .In this case , clean-up is required prior to the disposal of the interaction e.g. if the admission period ends and no student has matriculated for the course , teachers has to be finished before finishing the course itself .As rule 7 shows , the interaction is moved to the transient closing state and a corresponding event is inserted in the output port .According to invariant 20 , the closing event will be dispatched to every sub-interaction in order to activate its closing procedure guaranteed by invariant 8 .Moreover , 12This is essentially determined by the protocol rules of these interactions .The way in which the dispatching function is initialised and updated is out of the scope of this paper .the stage and ag fields are properly initialised so that the process goes on in the next member state update stage .This stage will further initiate the leaving process of the members according to invariant 9 .Eventually , every member will leave the interaction and every sub-interaction will be closed .Corresponding events will be received by the interaction according to invariants 23 and 22 so that the conditions of the first scenario will hold .This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocol 's over function .When all members have been checked , the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocol 's obligation update function .If some member has to end its participation in the interaction and it is not playing any role , it will be inmediately abandoned successfully or unsuccessfully , according to the satisfaction of its purpose .The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes inv .23 .Otherwise , the member enters the transient leaving state , thus preventing any action performance .Then , it waits for the completion of the leaving procedures of its played roles , triggered by proper dispatching of the leaving event inv .21 .In this stage , the obligations of agents not necessaryly members of the interaction towards the interaction are updated accordingly .When all the identified agents have been updated , the event is removed from the input queue and the stage field is set back to the interaction state update .For instance , when a course interaction receives an event representing the assignment of some department member to its subject , an obligation to join the course as a teacher is created for that member .Moreover , the event representing this change is added to the output channel of the department interaction .", "author_keywords_stem": ["social interaction", "software connector", "operational semantics"], "combined_keywords_stem": ["oper semant", "multiag interact", "institut framework", "pre-defin abstract", "organiz and commun abstract", "softwar architectur", "connector-base model of multi-agent interact", "multi-agent interact connector-base model", "formal execut semant", "organiz program languag", "softwar connector", "social interact", "structur oper semant"]}