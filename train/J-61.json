{"reader_keywords": ["iterative combinatorial exchange", "double auction", "combinatorial auction", "buyer and seller", "trade", "tree-based bidding language", "price", "winner-determination", "bidding", "threshold payment"], "reader_keywords_stem": ["iter combinatori exchang", "doubl auction", "combinatori auction", "buyer and seller", "trade", "tree-base bid languag", "price", "winner-determin", "bid", "threshold payment"], "introduction": "Combinatorial exchanges combine and generalize two different mechanisms : double auctions and combinatorial auctions .In a double auction DA , multiple buyers and sellers trade units of an identical good 20 .In a combinatorial auction CA , a single seller has multiple heterogeneous items up for sale 11 .Buyers may have complementarities or substitutabilities between goods , and are provided with an expressive bidding language .A common goal in both market * Corresponding author .Remaining authors in alphabetical order .parkes@eecs.harvard.edu sDivision of Engineering and Applied Sciences , Harvard University , Cambridge MA 02138 .designs is to determine the efficient allocation , which is the allocation that maximizes total value .A combinatorial exchange CE 24 is a combinatorial double auction that brings together multiple buyers and sellers to trade multiple heterogeneous goods .For example , in an exchange for wireless spectrum , a bidder may declare that she is willing to pay $ 1 million for a trade where she obtains licenses for New York City , Boston , and Philadelphia , and loses her license for Washington DC .Thus , unlike a DA , a CE allows all participants to express complex valuations via expressive bids .Unlike a CA , a CE allows for fragmented ownership , with multiple buyers and sellers and agents that are both buying and selling .CEs have received recent attention both in the context of wireless spectrum allocation 18 and for airport takeoff and landing slot allocation 3 .In both of these domains there are incumbents with property rights , and it is important to facilitate a complex multi-way reallocation of resources .Another potential application domain for CEs is to resource allocation in shared distributed systems , such as PlanetLab 13 .The instantiation of our general purpose design to specific domains is a compelling next step in our research .This paper presents the first design for an iterative combinatorial exchange ICE .The genesis of this project was a class , CS 286r `` Topics at the Interface between Economics and Computer Science , '' taught at Harvard University in Spring 2004.1 The entire class was dedicated to the design and prototyping of an iterative CE .The ICE design problem is multi-faceted and quite hard .The main innovation in our design is an expressive yet concise tree-based bidding language which generalizes known languages such as XOR/OR 23 , and the tight coupling of this language with efficient algorithms for price-feedback to guide bidding , winner-determination to determine trades , and revealed-preference activity rules to ensure progress across rounds .The exchange is iterative : bidders express upper and lower valuations on trades by annotating their bid-tree , and then tighten these bounds in response to price feedback in each round .The Threshold payment rule , introduced by Parkes et al. 24 , is used to determine final payments .The exchange has a number of interesting theoretical properties .For instance , when there exist linear prices we establish soundness and completeness : for straightforward bidders that adjust their bounds to meet activity rules while keeping their true value within the bounds , the exchange will terminate with the efficient allocation .In addition , theefficient allocation can often be determined without bidders revealing , or even knowing , their exact value for all trades .This is essential in complex domains where the valuation problem can itself be very challenging for a participant 28 .While we can not claim that straightforward bidding is an equilibrium of the exchange and indeed , should not expect to by the Myerson-Satterthwaite impossibility theorem 22 , the Threshold payment rule minimizes the ex post incentive to manipulate across all budget-balanced payment rules .The exchange is implemented in Java and is currently in validation .In describing the exchange we will first provide an overview of the main components and introduce several working examples .Then , we introduce the basic components for a simple one-shot variation in which bidders state their exact values for trades in a single round .We then describe the full iterative exchange , with upper and lower values , price-feedback , activity rules , and termination conditions .We state some theoretical properties of the exchange , and end with a discussion to motivate our main design decisions , and suggest some next steps .", "title": "ICE : An Iterative Combinatorial Exchange David C. Parkes * s Ruggiero Cavallos Nick Elprins Adam Judas S \u00b4 ebastien Lahaies", "author_keywords_stem": ["combinatorial exchange", "threshold payment", "vcg", "preference elicitation"], "abstract": "We present the first design for an iterative combinatorial exchange ICE .The exchange incorporates a tree-based bidding language that is concise and expressive for CEs .Bidders specify lower and upper bounds on their value for different trades .These bounds allow price discovery and useful preference elicitation in early rounds , and allow termination with an efficient trade despite partial information on bidder valuations .All computation in the exchange is carefully optimized to exploit the structure of the bid-trees and to avoid enumerating trades .A proxied interpretation of a revealedpreference activity rule ensures progress across rounds .A VCG-based payment scheme that has been shown to mitigate opportunities for bargaining and strategic behavior is used to determine final payments .The exchange is fully implemented and in a validation phase .", "id": "J-61", "combined_keywords_stem": ["iter combinatori exchang", "doubl auction", "combinatori auction", "buyer and seller", "trade", "tree-base bid languag", "price", "winner-determin", "bid", "threshold payment", "combinatori exchang", "vcg", "prefer elicit"], "combined_keywords": ["iterative combinatorial exchange", "double auction", "combinatorial auction", "buyer and seller", "trade", "tree-based bidding language", "price", "winner-determination", "bidding", "threshold payment", "combinatorial exchange", "vcg", "preference elicitation"], "author_keywords": ["combinatorial exchange", "threshold payment", "vcg", "preference elicitation"], "method": "The design has four main components , which we will introduce in order through the rest of the paper : 9 Expressive and concise tree-based bidding language .The language describes values for trades , such as `` my value for selling AB and buying C is $ 100 , '' or `` my value for selling ABC is $ 50 , '' with negative values indicating that a bidder must receive a payment for the trade to be acceptable .The language allows bidders to express upper and lower bounds on value , which can be tightened across rounds .9 Winner Determination .Winner-determination WD is formulated as a mixed-integer program MIP , with the structure of the bid-trees captured explicitly in the formulation .Comparing the solution at upper and lower values allows for a determination to be made about termination , with progress in intermediate rounds driven by an intermediate valuation and the lower values adopted on termination .9 Payments .Payments are computed using the Threshold payment rule 24 , with the intermediate valuations adopted in early rounds and lower values adopted on termination .9 Price feedback .An approximate price is computed for each item in the exchange in each round , in terms of the intermediate valuations and the provisional trade .The prices are optimized to approximate competitive equilibrium prices , and further optimized to best approximate the current Threshold payments with remaining ties broken to favor prices that are balanced across different items .In computing the prices , we adopt the methods of constraint-generation to exploit the structure of the bidding language and avoid enumerating all feasible trades .The subproblem to generate new constraints is a variation of the WD problem .9 Activity rule .A revealed-preference activity rule 1 ensures progress across rounds .In order to remain active , a bidder must tighten bounds so that there is enough information to define a trade that maximizes surplus at the current prices .Another variation on the WD problem is formulated , both to verify that the activity rule is met and also to provide feedback to a bidder to explain how to meet the rule .An outline of the ICE system flow of control is provided in Figure 1 .We will return to this example later in the paper .For now , just observe in this two-agent example that the agents state lower and upper bounds that are checked in the activity rule , and then passed to winner-determination WD , and then through three stages of pricing accuracy , fairness , balance .On passing the closing rule in which parameters aeff and athresh are checked for convergence of the trade and payments , the exchange goes to a last-and-final round .At the end of this round , the trade and payments are finally determined , based on the lower valuations .Many ascending-price one-sided CAs are known in the literature 10 , 25 , 29 .Direct elicitation approaches have also been proposed for one-sided CAs in which agents respond to explicit queries about their valuations 8 , 14 , 19 .A number of ascending CAs are designed to work with simple prices on items 12 , 17 .The price generation methods that we use in ICE generalize the methods in these earlier papers .Parkes et al. 24 studied sealed-bid combinatorial exchanges and introduced the Threshold payment rule .Subsequently , Krych 16 demonstrated experimentally that the Threshold rule promotes efficient allocations .We are not aware of any previous studies of iterative CEs .Dominant strategy DAs are known for unit demand 20 and also for single-minded agents 2 .No dominant strategy mechanisms are known for the general CE problem .ICE is a `` hybrid '' auction design , in that it couples simple item prices to drive bidding in early rounds with combinatorial WD and payments , a feature it shares with the clock-proxy design of Ausubel et al. 1 for one-sided CAs .We adopt a variation on the clock-proxy auctions 's revealedpreference activity rule .The bidding language shares some structural elements with the LGB language of Boutilier and Hoos 7 , but has very different semantics .Rothkopf et al. 27 also describe a restricted tree-based bidding language .In LGB , the semantics are those of propositional logic , with the same items in an allocation able to satisfy a tree in multiple places .Although this can make LGB especially concise in some settings , the semantics that we propose appear to provide useful `` locality , '' so that the value of one component in a tree can be understood independently from the rest of the tree .The idea of capturing the structure of our bidding language explicitly within a mixed-integer programming formulation follows the developments in Boutilier 6 .In our model , we consider a set of goods , indexed 1 , ... , m and a set of bidders , indexed 1 , ... , n .The initial allocation of goods is denoted x0 = x01 , ... , x0n , with x0i = x0i1 , ... , x0im and x0ij > 0 for good j indicating the numberof units of good j held by bidder i .A trade A = A1 , ... , An denotes the change in allocation , with Ai = Ai1 , ... , Aim where Aij E is the change in the number of units of item j to bidder i. So , the final allocation is x1 = x0 + A. Each bidder has a value vi Ai E for a trade Ai .This value can be positive or negative , and represents the change in value between the final allocation x0i + Ai and the initial allocation x0i .Utility is quasi-linear , with ui Ai , p = vi Ai \u2212 p for trade Ai and payment p E .Price p can be negative , indicating the bidder receives a payment for the trade .We use the term payoff interchangeably with utility .Our goal in the ICE design is to implement the efficient trade .The efficient trade , A * , maximizes the total increase in value across bidders .Constraints 1 ensure that no agent sells more items than it has in its initial allocation .Constraints 2 provide free disposal , and allows feasible trades to sell more items than are purchased but not vice versa .Later , we adopt Feas x0 to denote the set of feasible trades , given these constraints and given an initial allocation x0 = x01 , ... , x0 n .In this section , we provide three simple examples of instances that we will use to illustrate various components of the exchange .All three examples have only one seller , but this is purely illustrative .The `` OR '' indicates that the seller is willing to sell any number of goods .The `` XOR '' indicates that buyers 2 and 4 are willing to buy at most one of the two goods in which they are interested .The efficient trade is for bundle AB to go to buyer 1 and bundle CD to buyer 3 , denoted A * = \u2212 1 , \u2212 1 , \u2212 1 , \u2212 1 , +1 , +1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , +1 , +1 , 0 , 0 , 0 , 0 .The description of ICE is broken down into two sections : one-shot sealed-bid and iterative .In this section we abstract away the iterative aspect and introduce a specialization of the tree-based language that supports only exact values on nodes .The bidding language is designed to be expressive and concise , entirely symmetric with respect to buyers and sellers , and to extend to capture bids from mixed buyers and sellers , ranging from simple swaps to highly complex trades .Bids are expressed as annotated bid trees , and define a bidder 's value for all possible trades .The language defines changes in values on trades , with leaves annotated with traded items and nodes annotated with changes in values either positive or negative .The main feature is that it has a general `` interval-choose '' logical operator on internal nodes , and that it defines careful semantics for propagating values within the tree .We illustrate the language on each of Examples 1 3 in Figure 2 .The language has a tree structure , with trades on items defined on leaves and values annotated on nodes and leaves .The nodes have zero values where no value is indicated .Internal nodes are also labeled with interval-choose IC ranges .Given a trade , the semantics of the language define which nodes in the tree can be satisfied , or `` switched-on . ''First , if a child is on then its parent must be on .Second , if a parent node is on , then the number of children that are on must be within the IC range on the parent node .Finally , leaves in which the bidder is buying items can only be on if the items are provided in the trade .For instance , in Example 2 we can consider the efficient trade , and observe that in this trade all nodes in the trees of buyers 1 and 3 and also the seller , but none of the nodes in the trees of buyers 2 and 4 , can be on .On the other hand , inthe trade in which A goes to buyer 2 and D to buyer 4 , then the root and appropriate leaf nodes can be on for buyers 2 and 4 , but no nodes can be on for buyers 1 and 3 .Given a trade there is often a number of ways to choose the set of satisfied nodes .The semantics of the language require that the nodes that maximize the summed value across satisfied nodes be activated .Consider bid tree Ti from bidder i .This defines nodes ,3 Ti , of which some are leaves , Leaf i Ti .Let Child ,3 Ti denote the children of a node ,3 that is not itself a leaf .All nodes except leaves are labeled with the interval-choose operator ICxi ,3 , ICyi ,3 .Every node is also labeled with a value , vi ,3 .Each leaf ,3 is labeled with a trade , qi ,3 m i.e. , leaves can define a bundled trade on more than one type of item .Given a trade Ai to bidder i , the interval-choose operators and trades on leaves define which nodes can be satisfied .There will often be a choice .Ties are broken to maximize value .Let sati ,3 0 , 1 denote whether node ,3 is satisfied .Solution sati is valid given tree Ti and trade Ai , written sati valid Ti , Ai , if and only if :In words , a set of leaves can only be considered satisfied given trade Ai if the total increase in quantity summed across all such leaves is covered by the trade , for all goods Eq .4 .This works for sellers as well as buyers : for sellers a trade is negative and this requires that the total number of items indicated sold in the tree is at least the total number sold as defined in the trade .We also need `` upwards-propagation '' : any time a node other than the root is satisfied then its parent must be satisfied by ,3 EChild ,3 sati ,3 IC y i ,3 sati ,3 in Eq .5 .Finally , we need `` downwards-propagation '' : any time an internal node is satisfied then the appropriate number of children must also be satisfied Eq .5 .The total value of trade Ai , given bid-tree Ti , is defined as :The tree-based language generalizes existing languages .For instance : IC 2 , 2 on a node with 2 children is equivalent to an AND operator ; IC 1 , 3 on a node with 3 children is equivalent to an OR operator ; and IC 1 , 1 on a node with 2 children is equivalent to an XOR operator .Similarly , the XOR/OR bidding languages can be directly expressed as a bid tree in our language .2This section defines the winner determination problem , which is formulated as a MIP and solved in our implementation with a commercial solver .3 The solver uses branchand-bound search with dynamic cut generation and branching heuristics to solve large MIPs in economically feasible run times .2The OR * language is the OR language with dummy items to provide additional structure .OR * is known to be expressive and concise .However , it is not known whether OR * dominates XOR/OR in terms of conciseness 23 .3CPLEX , www.ilog.com In defining the MIP representation we are careful to avoid an XOR-based enumeration of all bundles .A variation on the WD problem is reused many times within the exchange , e.g. for column generation in pricing and for checking revealed preference .Given bid trees T = T1 , ... , Tte and initial allocation x0 , the mixed-integer formulation for WD is :Some goods may go unassigned because free disposal is allowed within the clearing rules of winner determination .These items can be allocated back to agents that sold the items , i.e. for which Aij < 0 .The Threshold payment rule is based on the payments in the Vickrey-Clarke-Groves VCG mechanism 15 , which itself is truthful and efficient but does not satisfy budget balance .Budget-balance requires that the total payments to the exchange are equal to the total payments made by the exchange .In VCG , the payment paid by agent i iswhere A * is the efficient trade , V * is the reported value of this trade , and V_i is the reported value of the efficient trade that would be implemented without bidder i .We call Avcg , i = V * \u2212 V_i the VCG discount .For instance , in Example 1 pvcg , seller = \u2212 10 \u2212 +10 \u2212 0 = \u2212 20 and pvcg , buyer = +20 \u2212 +10 \u2212 0 = 10 , and the exchange would run at a budget deficit of \u2212 20 + 10 = \u2212 10 .The Threshold payment rule 24 determines budgetbalanced payments to minimize the maximal error across all agents to the VCG outcome .Threshold payments are designed to minimize the maximal ex post incentive to manipulate .Krych 16 confirmed that Threshold promotes allocative efficiency in restricted and approximate Bayes-Nash equilibrium .We are now ready to introduce the iterative combinatorial exchange ICE design .Several new components are introduced , relative to the design for the one-shot exchange .Rather than provide precise valuations , bidders can provide lower and upper valuations and revise this bid information across rounds .The exchange provides price-based feedbackto guide bidders in this process , and terminates with an efficient or approximately-efficient trade with respect to reported valuations .In each round t 0 , 1 , ... the current lower and upper bounds , vt and vt , are used to define a provisional valuation profile v the a-valuation , together with a provisional trade At and provisional prices pt = pt 1 , ... , ptm on items .The a-valuation is a linear combination of the current upper and lower valuations , with aEFF 0 , 1 chosen endogenously based on the `` closeness '' of the optimistic trade at v and the pessimistic trade at v .Prices pt are used to inform an activity rule , and drive progress towards an efficient trade .The bidding language is extended to allow a bidder i to report a lower and upper value vi , vi on each node .These take the place of the exact value vi defined in Section 4.1 .Based on these labels , we can define the valuation functions vi Ti , Ai and vi Ti , Ai , using the exact same semantics as in Eq .6 .We say that such a bid-tree is well-formed if vi vi for all nodes .The following lemma is useful : LEMMA 1 .Given a well-formed tree , T , then vi Ti , Ai vi Ti , Ai for all trades .PROOF .Suppose there is some Ai for which vi Ti , Ai > vi Ti , Ai .Then , maxsatEvalid Ti , i ETi vi \u00b7 sat > maxsatEvalid Ti , i ETi vi \u00b7 sat .But , this is a contradiction because the trade A ' that defines vi Ti , Ai is still feasible with upper bounds vi , and vi vi for all nodes ,3 in a well-formed tree .In each round , approximate competitive-equilibrium CE prices , pt = pt 1 , ... , ptm , are determined .Given these provisional prices , the price on trade Ai for bidder i is pt Ai = j < m ptj \u00b7 Aij .CE prices will not always exist and we will often need to compute approximate prices 5 .We extend ideas due to Rassenti et al. 26 , Kwasnica et al. 17 and Dunford et al. 12 , and select approximate prices as follows : I : Accuracy .First , we compute prices that minimize the maximal error in the best-response constraints across all bidders .II : Fairness .Second , we break ties to prefer prices that minimize the maximal deviation from Threshold payments across all bidders .III : Balance .Third , we break ties to prefer prices that minimize the maximal price across all items .Taken together , these steps are designed to promote the informativeness of the prices in driving progress across rounds .In computing prices , we explain how to compute approximate or otherwise prices for structured bidding languages , and without enumerating all possible trades .For this , we adopt constraint generation to efficient handle an exponential number of constraints .Each step is described in detail below .I : Accuracy .We adopt a definition of price accuracy that generalizes the notions adopted in previous papers for unstructured bidding languages .Let At denote the current provisional trade and suppose the provisional valuation is v .To compute accurate CE prices , we consider :This linear program LP is designed to find prices that minimize the worst-case error across all agents .From the definition of CE prices , it follows that CE prices would have S = 0 as a solution to 9 , at which point trade Ati would be in the best-response set of every agent with Ati = , i.e. no trade , for all agents with no surplus for trade at the prices .EXAMPLE 5 .We can illustrate the formulation 9 on Example 2 , assuming for simplicity that v = v i.e. truth .The efficient trade allocates AB to buyer 1 and CD to buyerAn optimal solution requires p A = p B = 10/3 , with S = 2/3 , with p C and p D taking values such as p C = p D = 3/2 .But , 9 has an exponential number of constraints Eq .10 .Rather than solve it explicitly we use constraint generation 4 and dynamically generate a sufficient subset of constraints .Let i denote a manageable subset of all possible feasible trades to bidder i. Then , a relaxed version of 9 written ACC is formulated by substituting 10 withwhere i is a set of trades that are feasible for bidder i given the other bids .Fixing the prices p * , we then solve n subproblems one for each bidder ,to check whether solution p * , S * to ACC is feasible in problem 9 .In R-WD i the objective is to determine a most preferred trade for each bidder at these prices .Let \u02c6Ai denote the solution to R-WD i .Check condition :and if this condition holds for all bidders i , then solution p * , S * is optimal for problem 9 .Otherwise , trade \u02c6Ai is added to i for all bidders i for which this constraint isviolated and we re-solve the LP with the new set of constraints .4 II : Fairness .Second , we break remaining ties to prefer fair prices : choosing prices that minimize the worst-case error with respect to Threshold payoffs i.e. utility to bidders with Threshold payments , but without choosing prices that are less accurate .5 EXAMPLE 6 .For example , accuracy in Example 1 depicted in Figure 1 requires 12 pA + pB 16 for v = v .At these valuations the Threshold payoffs would be 2 to both the seller and the buyer .This can be exactly achieved in pricing with pA + pB = 14 .The fairness tie-breaking method is formulated as the following LP :where * represents the error in the optimal solution , from ACC .The objective here is the same as in the Threshold payment rule see Section 4.3 : minimize the maximal error between bidder payoff at v for the provisional trade and the VCG payoff at v .Problem FAIR is also solved through constraint generation , using R-WD i to add additional violated constraints as necessary .III : Balance .Third , we break remaining ties to prefer balanced prices : choosing prices that minimize the maximal price across all items .Returning again to Example 1 , depicted in Figure 1 , we see that accuracy and fairness require p A + p B = 14 .Finally , balance sets p A = p B = 7 .Balance is justified when , all else being equal , items are more likely to have similar than dissimilar values .6 The LP for balance is formulated as follows :where * represents the error in the optimal solution from ACC and * represents the error in the optimal solution from FAIR .Constraint generation is also used to solve BAL , generating new trades for i as necessary .4Problem R-WD i is a specialization of the WD problem , in which the objective is to maximize the payoff of a single bidder , rather than the total value across all bidders .It is solved as a MIP , by rewriting the objective in WD T , x0 as max vi \u00b7 sati \u2212 j p * j \u00b7 ij for agent i. Thus , the structure of the bid-tree language is exploited in generating new constraints , because this is solved as a concise MIP .The other bidders are kept around in the MIP but do not appear in the objective , and are used to define the space of feasible trades .5The methods of Dunford et al. 12 , that use a nucleolus approach , are also closely related .6The use of balance was advocated by Kwasnica et al. 17 .Dunford et al. 12 prefer to smooth prices across rounds .Comment 1 : Lexicographical Refinement .For all three sub-problems we also perform lexicographical refinement with respect to bidders in ACC and FAIR , and with respect to goods in BAL .For instance , in ACC we successively minimize the maximal error across all bidders .Given an initial solution we first `` pin down '' the error on all bidders for whom a constraint 11 is binding .For such a bidder i , the constraint is replaced withvi \u2212 p vand the error to bidder i no longer appears explicitly in the objective .ACC is then re-solved , and makes progress by further minimizing the maximal error across all bidders yet to be pinned down .This continues , pinning down any new bidders for whom one of constraints 11 is binding , until the error is lexicographically optimized for all bidders .7 The exact same process is repeated for FAIR and BAL , with bidders pinned down and constraints 15 replaced with * i vcg , i \u2212 v i ti \u2212 p ti , i , where * i is the current objective in FAIR , and items pinned down and constraints 18 replaced with p * j pj where p * j represents the target for the maximal price on that item in BAL .Comment 2 : Computation .All constraints in i are retained , and this set grows across all stages and across all rounds of the exchange .Thus , the computational effort in constraint generation is re-used .In implementation we are careful to address a number of `` issues '' that arise due to floating-point issues .We prefer to err on the side of being conservative in determining whether or not to add another constraint in performing check 13 .This avoids later infeasibility issues .In addition , when pinning-down bidders for the purpose of lexicographical refinement we relax the associated bidder-constraints with a small > 0 on the righthand side .The role of activity rules in the auction is to ensure both consistency and progress across rounds 21 .Consistency in our exchange requires that bidders tighten bounds as the exchange progresses .Activity rules ensure that bidders are active during early rounds , and promote useful elicitation throughout the exchange .We adopt a simple revealed-preference RP activity rule .The idea is loosely based around the RP-rule in Ausubel et al. 1 , where it is used for one-sided CAs .The motivation is to require more than simply consistency : we need bidders to provide enough information for the system to be able to to prove that an allocation is approximately efficient .It is helpful to think about the bidders interacting with `` proxy agents '' that will act on their behalf in responding to provisional prices pt-1 determined at the end of round t \u2212 1 .The only knowledge that such a proxy has of the valuation of a bidder is through the bid-tree .Suppose a proxy was queried by the exchange and asked which trade the bidder was most interested in at the provisional prices .The RP rule says the following : the proxy must have enough 7For example , applying this to accuracy on Example 2 we solve once and find bidders 1 and 2 are binding , for error * = 2/3 .We pin these down and then minimize the error to bidders 3 and 4 .Finally , this gives p A = p B = 10/3 and p C = p D = 5/3 , with accuracy 2/3 to bidders 1 and 2 and 1/3 to bidders 3 and 4 .information to be able to determine this surplus-maximizing trade at current prices .Consider the following examples : EXAMPLE 7 .A bidder has XOR + A , + B and a value of +5 on the leaf + A and a value range of 5,10 on leaf + B. Suppose prices are currently 3 for each of A and B .The RP rule is satisfied because the proxy knows that however the remaining value uncertainty on + B is resolved the bidder will always weakly prefer + B to + A. EXAMPLE 8 .A bidder has XOR + A , + B and value bounds 5 , 10 on the root node and a value of 1 on leaf + A. Suppose prices are currently 3 for each of A and B .The RP rule is satisfied because the bidder will always prefer + A to + B at equal prices , whichever way the uncertain value on the root node is ultimately resolved .Overloading notation , let vi E Ti denote a valuation that is consistent with lower and upper valuations in bid tree Ti .DEFINITION 4 .Bid tree Ti satisfies RP at prices pt \u2212 1 if and only if there exists some feasible trade L for which ,To make this determination for bidder i we solve a sequence of problems , each of which is a variation on the WD problem .First , we construct a candidate lower-bound trade , which is a feasible trade that solves :The solution l to RP1 i represents the maximal payoff that bidder i can achieve across all feasible trades , given its pessimistic valuation .Second , we break ties to find a trade with maximal value uncertainty across all possible solutions to RP1 i :We adopt solution L i as our candidate for the trade that may satisfy RP .To understand the importance of this tiebreaking rule consider Example 7 .The proxy can prove + B but not + A is a best-response for all vi E Ti , and should choose + B as its candidate .Notice that + B is a counterexample to + A , but not the other way round .Now , we construct a modified valuation \u02dcvi , by setting 24 vi , otherwise .where sat L i is the set of nodes that are satisfied in the lower-bound tree for trade L i .Given this modified valuation , we find U to solve :Let u denote the payoff from this optimal trade at modified values \u02dcv .We call trade Ui the witness trade .We show in Proposition 1 that the RP rule is satisfied if and only if l > u. Constructing the modified valuation as \u02dcvi recognizes that there is `` shared uncertainty '' across trades that satisfy the same nodes in a bid tree .Example 8 helps to illustrate this .Just using vi in RP3 i , we would find L i is `` buy A '' with payoff l = 3 but then find Ui is `` buy B '' with u = 7 and fail RP .We must recognize that however the uncertainty on the root node is resolved it will affect + A and + B in exactly the same way .For this reason , we set \u02dcvi = vi = 5 on the root node , which is exactly the same value that was adopted in determining l. Then , RP3 i applied to Ui gives `` buy A '' and the RP test is judged to be passed .where \u02dcvi is the modified valuation in Eq .24 .PROOF .For sufficiency , notice that the difference in payoff between trade L i and another trade i is unaffected by the way uncertainty is resolved on any node that is satisfied in both L i and i. Fixing the values in \u02dcvi on nodes satisfied in L i has the effect of removing this consideration when a trade Ui is selected that satisfies one of these nodes .On the other hand , fixing the values on these nodes has no effect on trades considered in RP3 i that do not share a node with L i .For the necessary direction , we first show that any trade that satisfies RP must solve RP1 i .Suppose otherwise , that some i with payoff greater than l satisfies RP .But , valuation vi E Ti together with L i presents a counterexample to RP Eq .20 .Now , suppose for contradiction that some i with maximal payoff l but uncertainty less than L i satisfies RP .Proceed by case analysis .Case a : only one solution to RP1 i has uncertain value and so i has certain value .But , this can not satisfy RP because L i with uncertain value would be a counterexample to RP Eq .20 .Case b : two or more solutions to RP1 i have uncertain value .Here , we first argue that one of these trades must satisfy a weak superset of all the nodes with uncertain value that are satisfied by all other trades in this set .This is by RP .Without this , then for any choice of trade that solves RP1 i , there is another trade with a disjoint set of uncertain but satisfied nodes that provides a counterexample to RP Eq .20 .Now , consider the case that some trade contains a superset of all the uncertain satisfied nodes of the other trades .Clearly RP2 i will choose this trade , L i , and i must satisfy a subset of these nodes by assumption .But , we now see that i can not satisfy RP because L i would be a counterexample to RP .Failure to meet the activity rule must have some consequence .In the current rules , the default action we choose is to set the upper bounds in valuations down to the maximal value of the provisional price on a node8 and the lowerbound value on that node .9 Such a bidder can remain active 8The provisional price on a node is defined as the minimal total price across all feasible trades for which the subtree rooted at the tree is satisfied .9This is entirely analogous to when a bidder in an ascending clock auction stops bidding at a price : she is not permitted to bid at a higher price again in future rounds .within the exchange , but only with valuations that are consistent with these new bounds .In each round , our default design provides every bidder with the provisional trade and also with the current provisional prices .See 7 for an additional discussion .We also provide guidance to help a bidder meet the RP rule .Let sat L * i and sat Ui * denote the nodes that are satisfied in trades L * i and Ui * , as computed in RP1 RP3 .LEMMA 2 .When RP fails , a bidder must increase a lower bound on at least one node in sat L * i \\ sat Ui * or decrease an upper bound on at least one node in sat Ui * \\ sat L * i in order to meet the activity rule .PROOF .Changing the upper or lower values on nodes that are not satisfied by either trade does not change L * i or Ui * , and does not change the payoff from these trades .Thus , the RP condition will continue to fail .Similarly , changing the bounds on nodes that are satisfied in both trades has no effect on revealed preference .A change to a lower bound on a shared node affects both L * i and Ui * identically because of the use of the modified valuation to determine Ui * .A change to an upper bound on a shared node has no effect in determining either L * i or Ui * .Note that when sat Ui * = sat L * i then condition 26 is always trivially satisfied , and so the guidance in the lemma is always well-defined when RP fails .This is an elegant feedback mechanism because it is adaptive .Once a bidder makes some changes on some subset of these nodes , the bidder can query the exchange .The exchange can then respond `` yes , '' or can revise the set of nodes sat * l and sat * u as necessary .Once each bidder has committed its new bids and either met the RP rule or suffered the penalty then round t closes .At this point , the task is to determine the new valuation , and in turn the provisional allocation t and provisional prices pt .A termination condition is also checked , to determine whether to move the exchange to a last-and-final round .To define the valuation we compute the following two quantities : Pessimistic at Pessimistic PP Determine an efficient trade , * l , at pessimistic values , i.e. to solve max i vi i , and set PP = i vi * li .Pessimistic at Optimistic PO Determine an efficient trade , * u , at optimistic values , i.e. to solve max i vi i , and set PO = i vi * ui .First , note that PP > PO and PP > 0 by definition , for all bid-trees , although PO can be negative because the `` right '' trade at v is not currently a useful trade at v .Recognizing this , definewhen PP > 0 , and observe that eff PP , PO > 1 when this is defined , and that eff PP , PO will start large and then trend towards 1 as the optimistic allocation converges towards the pessimistic allocation .In each round , we define eff E 0 , 1 as :which is 0 while PP is 0 and then trends towards 1 once PP > 0 in some round .This is used to define valuationwhich is used to define the provisional allocation and provisional prices .The effect is to endogenously define a schedule for moving from optimistic to pessimistic values across rounds , based on how `` close '' the trades are to one another .Termination Condition .In moving to the last-and-final round , and finally closing , we also care about the convergence of payments , in addition to the convergence towards an efficient trade .For this we introduce another parameter , thresh E 0 , 1 , that trends from 0 to 1 as the Threshold payments at lower and upper valuations converge .Consider the following parameter :which is defined for PP > 0 , where pthresh v denotes the Threshold payments at valuation profile v , Nactive is the number of bidders that are actively engaged in trade in the PP trade , and II II2 is the L2-norm .Note that thresh is defined for payments and not payoffs .This is appropriate because it is the accuracy of the outcome of the exchange that matters : i.e. the trade and the payments .Given this , we define 0 when PP is 0 31which is 0 while PP is 0 and then trends towards 1 as progress is made .DEFINITION 5 TERMINATION .ICE transitions to a lastand-final round when one of the following holds :where CUTOFFeff , CUTOFFthresh E 0 , 1 determine the accuracy required for termination .At the end of the last-and-final round v = v is used to define the final trade and the final Threshold payments .EXAMPLE 9 .Consider again Example 1 , and consider the upper and lower bounds as depicted in Figure 1 .First , if the seller 's bounds were 20 , 4 then there is an optimistic trade but no pessimistic trade , and PO = 4 and PP = 0 , and eff = 0 .At the bounds depicted , both the optimistic and the pessimistic trades occur and PO = PP = 4 and eff = 1 .However , we can see the Threshold payments are 17 , 17 at v but 14 , 14 at v. Evaluating thresh , wehave thresh = 1 + = 5/2 , and thresh = 2/5 .4/2 For CUTOFFthresh < 2/5 the exchange would remain open .On the other hand , if the buyer 's value for + AB was between 18 , 24 and the seller 's value for AB was between 12 , 6 , the Threshold payments are 15 , 15 at both upper and lower bounds , and thresh = 1 .ICE is approximately 6502 lines of Java code , broken up into the functional packages described in Table 1.10 The prototype is modular so that researchers may easily replace components for experimentation .In addition to the core exchange discussed in this paper , we have developed an agent component that allows a user to simulate the behavior and knowledge of other players in the system , better allowing a user to formulate their strategy in advance of actual play .A user specifies a valuation model in an XMLinterpretation of our bidding language , which is revealed to the exchange via the agent 's strategy .Major exchange tasks are handled by `` engines '' that dictate the non-optimizer specific logic .These engines drive the appropriate MIP/LP `` builders '' .We realized that all of our optimization formulations boil down to two classes of optimization problem .The first , used by winner determination , activity rule , closing rule , and constraint generation in pricing , is a MIP that finds trades that maximize value , holding prices and slacks constant .The second , used by the three pricing stages , is an LP that holds trades constant , seeking to minimize slack , profit , or prices .We take advantage of the commonality of these problems by using common LP/MIP builders that differ only by a few functional hooks to provide the correct variables for optimization .We have generalized our back-end optimization solver interface11 we currently support CPLEX and the LGPL licensed LPSolve , and can take advantage of the load-balancing and parallel MIP/LP solving capability that this library provides .", "conclusions": "In this work we designed and prototyped a scalable and highly-expressive iterative combinatorial exchange .The design includes many interesting features , including : a new bid-tree language for exchanges , a new method to construct approximate linear prices from expressive languages , and a proxied elicitation method with optimistic and pessimistic valuations with a new method to evaluate a revealed preference activity rule .The exchange is fully implemented in Java and is in a validation phase .The next steps for our work are to allow bidders to refine the structure of the bid tree in addition to values on the tree .We intend to study the elicitation properties of the exchange and we have put together a test suite of exchange problem instances .In addition , we are beginning to engage in collaborations to apply the design to airline takeoff and landing slot scheduling and to resource allocation in widearea network distributed computational systems ."}