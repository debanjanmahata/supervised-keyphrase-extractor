{"reader_keywords": ["online scheduling of job", "job online scheduling", "competitive ratio", "deterministic algorithm", "non-strategic setting", "deadline", "importance ratio", "zero laxity", "online algorithm", "quasi-linear function", "deterministic mechanism", "incentive compatibility", "individual rationality", "profitable deviation", "monotonicity"], "reader_keywords_stem": ["onlin schedul of job", "job onlin schedul", "competit ratio", "determinist algorithm", "non-strateg set", "deadlin", "import ratio", "zero laxiti", "onlin algorithm", "quasi-linear function", "determinist mechan", "incent compat", "individu ration", "profit deviat", "monoton"], "introduction": "We consider the problem of online scheduling of jobs on a single processor .Each job is characterized by a release time , a deadline , a processing time , and a value for successful completion by its deadline .The objective is to maximize the sum of the values of the jobs completed by their respective deadlines .The key challenge in this online setting is that the schedule must be constructed in real-time , even though nothing is known about a job until its release time .Competitive analysis 6 , 10 , with its roots in 12 , is a well-studied approach for analyzing online algorithms by comparing them against the optimal offline algorithm , which has full knowledge of the input at the beginning of its execution .One interpretation of this approach is as a game between the designer of the online algorithm and an adversary .First , the designer selects the online algorithm .Then , the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio : the ratio of the value of the jobs completed by an optimal offline algorithm to the value of those completed by the online algorithm .Two papers paint a complete picture in terms of competitive analysis for this setting , in which the algorithm is assumed to know k , the maximum ratio between the value densities value divided by processing time of any two jobs .For k = 1 , 4 presents a 4-competitive algorithm , and proves that this is a lower bound on the competitive ratio for deterministic algorithms .The same paper also generalizes the \\ / lower bound to 1 + k 2 for any k \u2265 1 , and 15 then \\ / presents a matching 1 + k 2-competitive algorithm .The setting addressed by these papers is completely nonstrategic , and the algorithm is assumed to always know the true characteristics of each job upon its release .However , in domains such as grid computing see , for example , 7 , 8 this assumption is invalid , because `` buyers '' of processor time choose when and how to submit their jobs .Furthermore , `` sellers '' not only schedule jobs but also determine the amount that they charge buyers , an issue not addressed in the non-strategic setting .Thus , we consider an extension of the setting in which each job is owned by a separate , self-interested agent .Instead of being released to the algorithm , each job is now released only to its owning agent .Each agent now has four different ways in which it can manipulate the algorithm : it decides when to submit the job to the algorithm after the true release time , it can artificially inflate the length of the job , and it can declare an arbitrary value and deadline for the job .Because the agents are self-interested , they will choose to manipulate the algorithm if doing so will causetheir job to be completed ; and , indeed , one can find examples in which agents have incentive to manipulate the algorithms presented in 4 and 15 .The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design 17 , the science of crafting protocols for self-interested agents .Recent years have seen much activity at the interface of computer science and mechanism design see , e.g. , 9 , 18 , 19 .In general , a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome .In our setting , a mechanism will take as input a job from each agent , and return a schedule for the jobs , and a payment to be made by each agent to the center .A basic solution concept of mechanism design is incentive compatibility , which , in our setting , requires that it is always in each agent 's best interests to immediately submit its job upon release , and to truthfully declare its value , length , and deadline .In order to evaluate a mechanism using competitive analysis , the adversary model must be updated .In the new model , the adversary still determines the sequence of jobs , but it is the self-interested agents who determine the observed input of the mechanism .Thus , in order to achieve a competitive ratio of c , an online mechanism must both be incentive compatible , and always achieve at least c1 of the value that the optimal offline mechanism achieves on the same sequence of jobs .The rest of the paper is structured as follows .In Section 2 , we formally define and review results from the original , non-strategic setting .After introducing the incentive issues through an example , we formalize the mechanism design setting in Section 3 .In Section 4 we present our first \u221a main result , a 1 + k 2 + 1 competitive mechanism , and formally prove incentive compatibility and the competitive ratio .We also show how we can simplify this mechanism for the special case in which k = 1 and each agent can not alter the length of its job .Returning the general setting , we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents .Finally , in Section 6 , we discuss related work other than the directly relevant 4 and 15 , before concluding with Section 7 .", "title": "Mechanism Design for Online Real-Time Scheduling", "author_keywords_stem": ["mechanism design", "game theory", "online algorithm", "schedule"], "abstract": "For the problem of online real-time scheduling of jobs on a single processor , previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm .However , these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm .Motivated by emerging areas such as grid computing , we instead consider this problem in an economic setting , in which each job is released to a separate , self-interested agent .The agent can then delay releasing the job to the algorithm , inflate its length , and declare an arbitrary value and deadline for the job , while the center determines not only the schedule , but the payment of each agent .For the resulting mechanism design problem in which we also slightly strengthen an assumption from the non-strategic setting , we present a mechanism that addresses each incentive issue , while only increasing the competitive ratio by one .We then show a matching lower bound for deterministic mechanisms that never pay the agents .", "id": "J-67", "combined_keywords_stem": ["onlin schedul of job", "job onlin schedul", "competit ratio", "determinist algorithm", "non-strateg set", "deadlin", "import ratio", "zero laxiti", "onlin algorithm", "quasi-linear function", "determinist mechan", "incent compat", "individu ration", "profit deviat", "monoton", "mechan design", "game theori", "schedul"], "combined_keywords": ["online scheduling of job", "job online scheduling", "competitive ratio", "deterministic algorithm", "non-strategic setting", "deadline", "importance ratio", "zero laxity", "online algorithm", "quasi-linear function", "deterministic mechanism", "incentive compatibility", "individual rationality", "profitable deviation", "monotonicity", "mechanism design", "game theory", "schedule"], "author_keywords": ["mechanism design", "game theory", "online algorithm", "schedule"], "method": "In this section , we formally define the original , non-strategic setting , and recap previous results .There exists a single processor on which jobs can execute , and N jobs , although this number is not known beforehand .Each job i is characterized by a tuple \u03b8i = ri , di , li , vi , which denotes the release time , deadline , length of processing time required , and value , respectively .The space \u0398i of possible tuples is the same for each job and consists of all \u03b8i such that ri , di , li , vi \u2208 ~ + thus , the model of time is continuous .Each job is released at time ri , at which point its three other characteristics are known .Nothing is known about the job before its arrival .Each deadline is firm or , hard , which means that no value is obtained for a job that is completed after its deadline .Preemption of jobs is allowed , and it takes no time to switch between jobs .Thus , job i is completed if and only if the total time it executes on the processor before di is at least li .Let \u03b8 = \u03b81 , ... , \u03b8N denote the vector of tuples for all jobs , and let \u03b8_i = \u03b81 , ... , \u03b8i_1 , \u03b8i +1 , ... , \u03b8N denote the same vector without the tuple for job i. Thus , \u03b8i , \u03b8_i denotes a complete vector of tuples .Define the value density \u03c1i = vi li of job i to be the ratio of its value to its length .For an input \u03b8 , denote the maximum and minimum value densities as \u03c1min = mini \u03c1i and \u03c1max = maxi \u03c1i .The importance ratio is then defined to be \u03c1max\u03c1min , the maximal ratio of value densities between two jobs .The algorithm is assumed to always know an upper bound k on the importance ratio .For simplicity , we normalize the range of possible value densities so that \u03c1min = 1 .An online algorithm is a function f : \u03981 \u00d7 ... \u00d7 \u0398N \u2192 O that maps the vector of tuples for any number N to an outcome o .An outcome o \u2208 O is simply a schedule of jobs on the processor , recorded by the function S : ~ + \u2192 0 , 1 , ... , N , which maps each point in time to the active job , or to 0 if the processor is idle .To denote the total elapsed time that a job has spent on the processor at time t , we will use the function ei t = f0 t \u00b5 S x = i dx , where\u00b5 \u00b7 is an indicator function that job 's laxity at time t is defined to be di \u2212 t \u2212 li + ei t , returns 1 if the argument is true , and zero otherwise .A the amount of time that it can remain inactive and still be completed by its deadline .A job is abandoned if it can not be completed by its deadline formally , if di \u2212 t + ei t < li .Also , overload S \u00b7 and ei \u00b7 so that they can also take a vector \u03b8 as an argument .For example , S \u03b8 , t is shorthand for the S t of the outcome f \u03b8 , and it denotes the active job at time t when the input is \u03b8 .Since a job can not be executed before its release time , the space of possible outcomes is restricted in that S \u03b8 , t = i implies ri \u2264 t. Also , because the online algorithm must produce the schedule over time , without knowledge of future inputs , it must make the same decision at time t for inputs that are indistinguishable at this time .Formally , let \u03b8 t denote the subset of the tuples in \u03b8 that satisfy ri \u2264 t .The constraint is then that \u03b8 t = \u03b8 ' t implies S \u03b8 , t = S \u03b8 ' , t .The objective function is the sum of the values of the jobs that are completed by their respective deadlines : W o , \u03b8 = E vi \u00b7 \u00b5 ei \u03b8 , di \u2265 li .Let W * \u03b8 = maxoEO W o , \u03b8 i denote the maximum possible total value for the profile \u03b8 .In competitive analysis , an online algorithm is evaluated by comparing it against an optimal offline algorithm .Because the offline algorithm knows the entire input \u03b8 at time 0 but still can not start each job i until time ri , it always achieves W * \u03b8 .An online algorithm f \u00b7 is strictly c-competitive if there does not exist an input \u03b8 such that c \u00b7 W f \u03b8 , \u03b8 < W * \u03b8 .An algorithm that is c-competitive is also said to achieve a competitive ratio of c .We assume that there does not exist an overload period of infinite duration .A period of time ts , tf is overloaded if the sum of the lengths of the jobs whose release time and tion of the interval formally , if tf \u2212 ts \u2264 E deadline both fall within the time period exceeds the durai1 ts < ri , di < tf li .Without such an assumption , it is not possible to achieve a finite competitive ratio 15 .In the non-strategic setting , 4 presents a 4-competitive algorithm called TD1 version 2 for the case of k = 1 , while \u221a 15 presents a 1 + k 2-competitive algorithm called Dover for the general case of k \u2265 1 .Matching lower bounds for deterministic algorithms for both of these cases were shown\u00b5 in 4 .In this section we provide a high-level description of TD1 version 2 using an example .TD1 version 2 divides the schedule into intervals , each of which begins when the processor transitions from idle to busy call this time tb , and ends with the completion of a job .The first active job of an interval may have laxity ; however , for the remainder of the interval , preemption of the active job is only considered when some other job has zero laxity .For example , when the input is the set of jobs listed in Table 1 , the first interval is the complete execution of job 1 over the range 0.0 , 0.9 .No preemption is considered during this interval , because job 2 has laxity until time 1.5 .Then , a new interval starts at tb = 0.9 when job 2 becomes active .Before job 2 can finish , preemption is considered at time 4.8 , when job 3 is released with zero laxity .In order to decide whether to preempt the active job , TD1 version 2 uses two more variables : te and p loss .The former records the latest deadline of a job that would be abandoned if the active job executes to completion or , if no such job exists , the time that the active job will finish if it is not preempted .In this case , te = 17.0 .The value te \u2212 tb represents the an upper bound on the amount of possible execution time `` lost '' to the optimal offline algorithm due to the completion of the active job .The other variable , p loss , is equal to the length of the first active job of the current interval .Because in general this job could have laxity , the offline algorithm may be able to complete it outside of the range tb , te .1 If the algorithm completes the active job and this job 's length is at least te \u2212 tb + p loss , then thealgorithm is guaranteed to be 4-competitive for this interval note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio .Because this is not case at time 4.8However , false information about job 2 would cause TD1 version 2 to complete this job .For example , if job 2 's dead\u02c6d2 = 4.7 , then it would have zero laxity at time 0.7 .At this time , the algorithm would preempt jobJob 2 would then complete before the arrival of job 3.2In order to address incentive issues such as this one , we need to formalize the setting as a mechanism design problem .In this section we first present the mechanism design formulation , and then define our goals for the mechanism .There exists a center , who controls the processor , and N agents , where the value of N is unknown by the center beforehand .Each job i is owned by a separate agent i .The characteristics of the job define the agent 's type \u03b8i \u2208 \u0398i .At time ri , agent i privately observes its type \u03b8i , and has no information about job i before ri .Thus , jobs are still released over time , but now each job is revealed only to the owning agent .Agents interact with the center through a direct mechanism \u0393 = \u03981 , ... , \u0398N , g \u00b7 , in which each agent declares a \u02c6\u03b8i = \u02c6ri , \u02c6di , \u02c6li , \u02c6vi , and g : \u03981 \u00d7 ... \u00d7 \u0398N \u2192 O maps the declared types to an outcome o \u2208 O .An outcome o = S \u00b7 , p1 , ... , pN consists of a schedule and a payment from each agent to the mechanism .In a standard mechanism design setting , the outcome is enforced at the end of the mechanism .However , since the end is not well-defined in this online setting , we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at \u02c6di , which , according to the agent 's declaration , is the latest relevant point of time for that agent .That is , even if job i is completed before \u02c6di , the center does not return the job to agent i until that time .This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms .Indeed , as we will discuss later , this decision of when to return a completed job is crucial to our mechanism .Each agent 's utility , ui g \u02c6\u03b8 , \u03b8i = vi \u00b7 \u00b5 ei \u02c6\u03b8 , di \u2265 li \u00b7 \u02c6di \u2264 di \u2212 pi \u02c6\u03b8 , is a quasi-linear function of its value for its job if completed and returned by its true deadline and the payment it makes to the center .We assume that each agent is a rational , expected utility maximizer .Agent declarations are restricted in that an agent can not declare a length shorter than the true length , since the center would be able to detect such a lie if the job were completed .On the other hand , in the general formulation we will allow agents to declare longer lengths , since in some settings it may be possible add unnecessary work to a job .However , we will also consider a restricted formulation in which this type of lie is not possible .The declared release time \u02c6ri is the time that the agent chooses to submit job i to the center , and it can not precede the time ri at which the job is revealed to the agent .The agent can declare an arbitrary deadline or value .To summarize , agent i can declare any type \u02c6\u03b8i = \u02c6ri , \u02c6di , \u02c6li , \u02c6vi such that \u02c6li \u2265 li and \u02c6ri \u2265 ri .While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio \u03c1max \u03c1min , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows \u03c1min or , equivalently , the range \u03c1min , \u03c1max of possible value densities .3 Dover , we note that it is similar in its use of intervals and its preference for the active job .Also , we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover .3Note that we could then force agent declarations to satisfy \u03c1min \u2264 \u02c6vi \u02c6li \u2264 \u03c1max .However , this restriction would notWhile we feel that it is unlikely that a center would know k without knowing this range , we later present a mechanism that does not depend on this extra knowledge in a restricted setting .The restriction on the schedule is now that S \u02c6\u03b8 , t = i implies \u02c6ri < t , to capture the fact that a job can not be scheduled on the processor before it is declared to the mechanism .As before , preemption of jobs is allowed , and job switching takes no time .The constraints due to the online mechanism 's lack of knowledge of the future are that \u02c6\u03b8 t = \u02c6\u03b8 ~ t implies S \u02c6\u03b8 , t = S \u02c6\u03b8 ~ , t , and \u02c6\u03b8 \u02c6di = \u02c6\u03b8 ~ \u02c6di implies pi \u02c6\u03b8 = pi \u02c6\u03b8 ~ for each agent i .The setting can then be summarized as follows .The center instantiates S \u02c6\u03b8 , t + i , for some i s.t. \u02c6ri < t if 3i , ri = t then \u03b8i is revealed to agent iCenter sets and collects payment pi \u02c6\u03b8 from agent iOur aim as mechanism designer is to maximize the value of completed jobs , subject to the constraints of incentive compatibility and individual rationality .The condition for dominant strategy incentive compatibility is that for each agent i , regardless of its true type and of the declared types of all other agents , agent i can not increase its utility by unilaterally changing its declaration .From an agent perspective , dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agent 's types are drawn .From a mechanism designer perspective , dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it .For these reasons , in this paper we require dominant strategies , as opposed to a weaker equilibrium concept such as Bayes-Nash , under which we could improve upon our positive results .4 decrease the lower bound on the competitive ratio .4A possible argument against the need for incentive compatibility is that an agent 's lie may actually improve the schedule .In fact , this was the case in the example we showed for the false declaration \u02c6d2 = 4.7 .However , if an agent lies due to incorrect beliefs over the future input , then the lie could instead make the schedule the worse for example , if job 3 were never released , then job 1 would have been unnecessarily abandoned .Furthermore , if we do not know the beliefs of the agents , and thus can not predict how they will lie , then we can no longer provide a competitive guarantee for our mechanism .While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first , the Revelation Principle for Dominant Strategies see , e.g. , 17 tells us that if our goal is dominant strategy implementation , then we can make this restriction without loss of generality .The second goal for our mechanism , individual rationality , requires that agents who truthfully reveal their type never have negative utility .The rationale behind this goal is that participation in the mechanism is assumed to be voluntary .Finally , the social welfare function that we aim to maximize is the same as the objective function of the non-strategicstrategic setting , we will evaluate an online mechanism using competitive analysis to compare it against an optimal offline mechanism which we will denote by \u0393off line .An offline mechanism knows all of the types at time 0 , and thus can always achieve W \u2217 \u03b8 .51 + In this section , we first present our main positive result : a \u2713 k 2 +1 competitive mechanism \u03931 .After providing some intuition as to why \u03931 satisfies individual rationality and incentive compatibility , we formally prove first these two properties and then the competitive ratio .We then consider a special case in which k = 1 and agents can not lie about the length of their job , which allows us to alter this mechanism so that it no longer requires either knowledge of \u03c1min or the collection of payments from agents .Unlike TD1 version 2 and Dover , \u03931 gives no preference to the active job .Instead , it always executes the avail \u2713 able job with the highest priority : \u02c6vi + k \u2022 ei \u02c6\u03b8 , t \u2022 \u03c1min .Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed , holding constant the rest of its declaration .By the use of a payment rule similar to that of a secondprice auction , \u03931 satisfies both IC with respect to values and IR .We now argue why it satisfies IC with respect to the other three characteristics .Declaring an `` improved '' job i.e. , declaring an earlier release time , a shorter length , or a later deadline could possibly decrease the payment of an agent .However , the first two lies are not possible in our setting , while the third would cause the job , if it is completed , to be returned to the agent after the true deadline .This is the reason why it is important to always return a completed job at its declared deadline , instead of at the point at which it is completed .5Another possibility is to allow only the agents to know their types at time 0 , and to force \u0393of f line to be incentive compatible so that agents will truthfully declare their types at time 0 .However , this would not affect our results , since executing a VCG mechanism see , e.g. , 17 at time 0 both satisfies incentive compatibility and always maximizes social welfare .It remains to argue why an agent does not have incentive to `` worsen '' its job .The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned , and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier which has no effect on the agent 's utility in our setting .On the other hand , it is less obvious why agents do not have incentive to declare a later release time .Consider a mechanism \u0393 ~ 1 that differs from \u03931 in that it does not preempt the active job i unless there exists an \u221a other job j such that \u02c6vi + k \u00b7 li \u02c6\u03b8 , t \u00b7 \u03c1min < \u02c6vj .Note that as an active job approaches completion in \u03931 , its condition for preemption approaches that of \u0393 ~ 1 .However , the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under \u0393 ~ 1 .Job 1 becomes active at time 0 , and job 2 is abandoned upon its release at time 6 , because 10 + 10 = v1 + l1 > v2 = 13 .Then , at time 8 , job 1 is preempted by job 3 , because 10 + 10 = v1 + l1 < v3 = 22 .Job 3 then executes to completion , forcing job 1 to be abandoned .However , job 2 had more `` weight '' than job 1 , and would have prevented job 3 from being executed if it had been the active job at time 8 , since 13 + 13 = v2 + l2 > v3 = 22 .Thus , if agent 1 had falsely declared \u02c6r1 = 20 , then job 3 would have been abandoned at time 8 , and job 1 would have completed over the range 20 , 30 .Intuitively , \u03931 avoids this problem because of two properties .First , when a job becomes active , it must have a greater priority than all other available jobs .Second , because a job 's priority can only increase through the increase of its elapsed time , ei \u02c6\u03b8 , t , the rate of increase of a job 's priority is independent of its characteristics .These two properties together imply that , while a job is active , there can not exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead .After presenting the trivial proof of IR , we break the proof of IC into lemmas .THEOREM 1 .Mechanism \u03931 satisfies individual rationality .PROOF .For arbitrary i , \u03b8i , \u02c6\u03b8 \u2212 i , if job i is not completed , then agent i pays nothing and thus has a utility of zero ; that is , pi \u03b8i , \u02c6\u03b8 \u2212 i = 0 and ui g \u03b8i , \u02c6\u03b8 \u2212 i , \u03b8i = 0 .On the other hand , if job i is completed , then its value must exceed agent i 's payment .Formally , ui g \u03b8i , \u02c6\u03b8 \u2212 i , \u03b8i = vi \u2212 arg minvii \u2265 0 ei ri , di , li , v ~ i , \u02c6\u03b8 \u2212 i , di \u2265 li \u2265 0 must hold , since v ~ i = vi satisfies the condition .To prove IC , we need to show that for an arbitrary agent i , and an arbitrary profile \u02c6\u03b8 \u2212 i of declarations of the other agents , agent i can never gain by making a false declaration \u02c6\u03b8i = ~ \u03b8i , subject to the constraints that \u02c6ri \u2265 ri and \u02c6li \u2265 li .We start by showing that , regardless of \u02c6vi , if truthful declarations of ri , di , and li do not cause job i to be completed , then `` worse '' declarations of these variables that is , declarations that satisfy \u02c6ri \u2265 ri , \u02c6li \u2265 li and \u02c6di \u2264 di can never cause the job to be completed .We break this part of the proof into two lemmas , first showing that it holds for the release time , regardless of the declarations of the other variables , and then for length and deadline .PROOF .Assume by contradiction that this condition does not hold that is , job i is not completed when ri is truthfully declared , but is completed for some false declaration \u02c6ri \u2265 ri .We first analyze the case in which the release time is truthfully declared , and then we show that job i can not be completed when agent i delays submitting it to the center .Case I : Agent i declares \u02c6\u03b8 ~ i = ri , \u02c6di , \u02c6li , \u02c6vi .First , define the following three points in the execution of job i.If ts and tp are undefined because job i never becomes active , then let ts = tp = ta .Also , partition the jobs declared by other agents before ta into the following three sets .We now show that all active jobs during the range tp , ta must be either i or in the set Y .Unless tp = ta in which case this property trivially holds , it must be the case that job i has a higher priority than an arbitrary job x \u2208 X at time tp , since at the time just preceding tp job x was available and jobi was active .Formally , \u02c6vx + k \u00b7 ex \u02c6\u03b8 ' i , \u02c6\u03b8_i , tp < \u02c6vi + k \u00b7 ei \u02c6\u03b8 ' i , \u02c6\u03b8_i , tp must hold .6 We can then show that , over the range tp , ta , no job x \u2208 X runs on the processor .Assume by contradiction that this is not true .Let tf \u2208 tp , ta be the earliest time in this range that some job x \u2208 X is active , which implies that ex \u02c6\u03b8 ` i , \u02c6\u03b8_i , tf = ex \u02c6\u03b8 ` i , \u02c6\u03b8_i , tp .\u02c6\u03b8i = \u02c6ri , \u02c6di , \u02c6li , \u02c6vi , where \u02c6ri > ri .We now show that job i can not be completed in this case , given that it was not completed in case I. First , we can restrict the range of \u02c6ri that we need to consider as follows .Declaring \u02c6ri \u2208 ri , ts would not affect the schedule , since ts would still be the first time that job i executes .Also , declaring \u02c6ri > ta could not cause the job to be completed , since di \u2212 ta < \u02c6li holds , which implies that job i would be abandoned at its release .Thus , we can restrict consideration to \u02c6ri \u2208 ts , ta .In order for declaring \u02c6\u03b8i to cause job i to be completed , a necessary condition is that the execution of some job yc \u2208 Y must change during the range tp , ta , since the only jobs other than i that are active during that range are in Y .\u02c6\u03b8_i , t = yc \u2227 S \u02c6\u03b8i , \u02c6\u03b8_i , t = ~ yc be the first time that such a change occurs .We will now show that for any \u02c6ri \u2208 ts , ta , there can not exist a job with higher priority than yc at time tc , contradicting S \u02c6\u03b8i , \u02c6\u03b8_i , t = ~ yc .First note that job i can not have a higher priority , since there would have to exist a t \u2208 tp , tc such that \u2203 y \u2208 6For simplicity , when we give the formal condition for a job x to have a higher priority than another job y , we will assume that job x 's priority is strictly greater than job y 's , because , in the case of a tie that favors x , future ties would also be broken in favor of job x.the definition of tc .Now consider an arbitrary y \u2208 Y such that y = ~ yc .In case I , we know that job y has lower priority than yc at time tc ;Thus , moving to case II , job y must replace some other job before tc .Since \u02c6ry \u2265 tp , the condition is that there must exist some t \u2208 tp , tc such that \u2203 w \u2208 Y \u222a i , S \u02c6\u03b8 ` i , \u02c6\u03b8_i , t = w \u2227 S \u02c6\u03b8i , \u02c6\u03b8_i , t = y .Since w \u2208 Y would contradict the definition of tc , we know that w = i .That is , the job that y replaces must be i. By definition of the set Y , we know that \u221a \u02c6vy > \u02c6vi + k \u00b7 ei \u02c6\u03b8 ' i , \u02c6\u03b8_i , \u02c6ry .Thus , if \u02c6ry \u2264 t , then job i could not have executed instead of y in case I. On the other hand , if \u02c6ry > t , then job y obviously could not execute at time t , contradicting the existence of such a time t .Now consider an arbitrary job x \u2208 X .We know that in case I job i has a higher priority than job x at time\u02c6vyc + k \u00b7 eyc \u02c6\u03b8 ' i , \u02c6\u03b8_i , tc .Since delaying i 's arrival will not affect the execution up to time ts , and since job x can not execute instead of a job y \u2208 Y at any time t \u2208 tp , tc by definition of tc , the only way for job x 's priority to increase before tc as we move from case I to II is to replace job i over the range ts , tc .Thus , an upper bound on job x 's priority when agent i declares \u02c6\u03b8i is :Thus , even at this upper bound , job yc would execute instead of job x at time tc .A similar argument applies to an arbitrary job z \u2208 Z , starting at it release time \u02c6rz .Since the sets i , X , Y , Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof .LEMMA 3 .In mechanism \u03931 , the following condition holds for all i , \u03b8i , \u02c6\u03b8_i : \u2200 \u02c6vi , \u02c6li \u2265 li , \u02c6di \u2264 di , ~ ei ~ ri , \u02c6di , \u02c6li , \u02c6vi , \u02c6\u03b8_i , \u02c6di ~ \u2265 \u02c6li ~ = \u21d2 ~ ei ~ ~ ri , di , li , \u02c6vi , \u02c6\u03b8_i , \u02c6di ~ \u2265 li PROOF .Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared , but is completed for some pair of false declarations \u02c6li \u2265 li and \u02c6di \u2264 di .Note that the only effect that \u02c6di and \u02c6li have on the execution of the algorithm is on whether or not i \u2208 Avail .Specifically , they affect the two conditions : ei \u02c6\u03b8 , t < \u02c6li and ei \u02c6\u03b8 , t + \u02c6di \u2212 t \u2265 \u02c6li .Because job i is completed when \u02c6li and \u02c6di are declared , the former condition for completion must become false before the latter .Since truthfully declaring li \u2264 \u02c6li and di \u2265 \u02c6di will only make the former condition become false earlier and the latter condition become false later , the execution of the algorithm will not be affected when moving to truthful declarations , and job i will be completed , a contradiction .We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring `` worse '' \u02c6li , \u02c6di , and \u02c6ri .We can then show that job i has a higher priority at time tf as \u221a \u221a follows : \u02c6vx + k \u00b7 ex \u02c6\u03b8 ' i , \u02c6\u03b8_i , tf = \u02c6vx + k \u00b7 ex \u02c6\u03b8 ' i , \u02c6\u03b8_i , tp < \u221a \u221a \u02c6vi + k \u00b7 ei \u02c6\u03b8 ' i , \u02c6\u03b8_i , tp \u2264 \u02c6vi + k \u00b7 ei \u02c6\u03b8 ' i , \u02c6\u03b8_i , tf , contradicting the fact that job x is active at time tf .A similar argument applies to an arbitrary job z \u2208 Z , starting at it release time \u02c6rz > tp , since by definition job i has a higher priority at that time .The only remaining jobs that can be active over the range tp , ta are i and those in the set Y .Case II : Agent i declares Let tc = arg mintE tp , ta \u2203 yc \u2208 Y , SPROOF .Assume by contradiction that this condition does not hold .This implies that there exists some value v ~ i such that the condition ei \u02c6ri , \u02c6di , \u02c6li , v ~ i , \u02c6\u03b8_i , \u02c6di \u2265 \u02c6li holds , but ei ri , di , li , v ~ i , \u02c6\u03b8_i , di \u2265 li does not .Applying Lemmas 2 and 3 : ei \u02c6ri , \u02c6di , \u02c6li , v ~ i , \u02c6\u03b8_i , \u02c6di \u2265 \u02c6li = \u21d2Finally , the following lemma tells us that the completion of a job is monotonic in its declared value .~ ei ~ ~ \u02c6ri , \u02c6di , \u02c6li , \u02c6v ~ i , \u02c6\u03b8_i , \u02c6di ~ \u2265 \u02c6li The proof , by contradiction , of this lemma is omitted because it is essentially identical to that of Lemma 2 for \u02c6ri .In case I , agent i declares \u02c6ri , \u02c6di , \u02c6li , \u02c6v ~ i and the job is not completed , while in case II he declares \u02c6ri , \u02c6di , \u02c6li , \u02c6vi and the job is completed .The analysis of the two cases then proceeds as before the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II ; and , as a result , there can not be a change in the execution of a job other than i over the range tp , ta .We can now combine the lemmas to show that no profitable deviation is possible .THEOREM 6 .Mechanism \u03931 satisfies incentive compatibility .PROOF .For an arbitrary agent i , we know that \u02c6ri \u2265 ri and \u02c6li \u2265 li hold by assumption .We also know that agent i has no incentive to declare \u02c6di > di , because job i would never be returned before its true deadline .Then , because the payment function is non-negative , agent i 's utility could not exceed zero .By IR , this is the minimum utility it would achieve if it truthfully declared \u03b8i .Thus , we can restrict consideration to \u02c6\u03b8i that satisfy \u02c6ri \u2265 ri , \u02c6li \u2265 li , and \u02c6di \u2264 di .Again using IR , we can further restrict consideration to \u02c6\u03b8i that cause job i to be completed , since any other \u02c6\u03b8i yields a utility of zero .If truthful declaration of \u03b8i causes job i to be completed , then by Lemma 4 any such false declaration \u02c6\u03b8i could not decrease the payment of agent i. On the other hand , if truthful declaration does not cause job i to be completed , then declaring such a \u02c6\u03b8i will cause agent i to have negativeLemmas 5 and 4 , respectively .The proof of the competitive ratio , which makes use of techniques adapted from those used in 15 , is also broken into lemmas .Having shown IC , we can assume truthful declaration \u02c6\u03b8 = \u03b8 .Since we have also shown IR , in order to prove the competitive ratio it remains to bound the loss of social welfare against \u0393off line .Denote by 1 , 2 , ... , F the sequence of jobs completed by \u03931 .Divide time into intervals If = topen f , tclose f , one for each job f in this sequence .Set tclose f to be the time at which job f is completed , and set topenf be the first time that the processor is not idle in interval If .LEMMA 7 .For any interval If , the following inequality holds : tclose f \u2212 tbegin f \u2264 1 + \u221a 1k \u00b7 vf PROOF .Interval If begins with a possibly zero length period of time in which the processor is idle because there is no available job .Then , it continuously executes a sequence of jobs 1 , 2 , ... , c , where each job i in this sequence is preempted by job i + 1 , except for job c , which is completed thus , job c in this sequence is the same as job f is the global sequence of completed jobs .Let tsi be the time that job i begins execution .Note that ts1 = tbegin f .\u221a Over the range tbegin f , tclose f , the priority vi + k \u00b7 ei \u03b8 , t of the active job is monotonically increasing with time , because this function linearly increases while a job is active , and can only increase at a point in time when preemption occurs .Thus , each job i > 1 in this sequence begins execution at its release time that is , tsi = ri , because its priority does not increase while it is not active .We now show that the value of the completed job c ex \u221a ceeds the product of k and the time spent in the interval on jobs 1 through c \u2212 1 , or , more formally , that the following \u221a k ~ c_1 condition holds : vc \u2265 h = 1 eh \u03b8 , ts h +1 \u2212 eh \u03b8 , tsh .To show this , we will prove by induction that the stronger con \u221a k ~ i_1Base Case : For i = 1 , v1 \u2265 h = 1 eh \u03b8 , tsh +1 = 0 , since the sum is over zero elements .Inductive Step : For an arbitrary 1 \u2264 i < c , we assume \u221a k ~ i_1 that vi \u2265 h = 1 eh \u03b8 , tsh +1 holds .At time tsi +1 , we \u221a know that vi +1 \u2265 vi + k \u00b7 ei \u03b8 , tsi +1 holds , because tsi +1 = ri +1 .These two inequalities together imply that vi +1 \u2265 \u221a k ~ ih = 1 eh \u03b8 , tsh +1 , completing the inductive step .We also know that tclose f \u2212 tsc \u2264 lc \u2264 vc must hold , by the simplifying normalization of \u03c1min = 1 and the fact that job c 's execution time can not exceed its length .We can thus bound the total execution time of If by : tcloseWe now consider the possible execution of uncompleted jobs by \u0393off line .Associate each job i that is not completed by \u03931 with the interval during which it was abandoned .All jobs are now associated with an interval , since there are no gaps between the intervals , and since no job i can be abandoned after the close of the last interval at tclose F .Because the processor is idle after tclose F , any such job i would become active at some time t \u2265 tclose F , which would lead to the completion of some job , creating a new interval and contradicting the fact that IF is the last one .LEMMA 5 .In mechanism \u03931 , the following condition holds for all i , \u02c6\u03b8i , \u02c6\u03b8_i : \u2200 \u02c6v ~ i \u2265 \u02c6vi , ~ ei ~ \u02c6ri , \u02c6di , \u02c6li , \u02c6vi , \u02c6\u03b8_i , \u02c6di ~ \u2265 \u02c6li ~ = \u21d2The following lemma is equivalent to Lemma 5.6 of 15 , but the proof is different for our mechanism .\u221a in If , the following inequality holds : vi \u2264 1 + k vf .PROOF .Assume by contradiction that there exists a jobthe priority of job f is vf + k \u00b7 lf < 1 + k vf .Because the priority of the active job monotonically increases over the range tbegin f , tclose f , job i would have a higher priority than the active job and thus begin execution at some time t \u2208 tbeginf , tclose f .Again applying monotonicity , this would imply that the priority of the active job at tcloseAs in 15 , for each interval If , we give \u0393off line the following `` gift '' : k times the amount of time in the range tbegin f , tclose f that it does not schedule a job .Additionally , we `` give '' the adversary vf , since the adversary may be able to complete this job at some future time , due to the fact that \u03931 ignores deadlines .The following lemma is Lemma 5.10 in 15 , and its proof now applies directly .LEMMA 9 .15 With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs \u221a abandoned during If is not greater than 1 + k \u00b7 vf .The intuition behind this lemma is that the best that the adversary can do is to take almost all of the `` gift '' off intuitively , this is equivalent to executing jobs with the maximum possible value density over the time that \u03931 is active , and then begin execution of a job abandoned by \u03931 right before tclose f .By Lemma 8 , the value of \u221a this job is bounded by 1 + k \u00b7 vf .We can now combine the results of these lemmas to prove the competitive ratio .THEOREM 10 .Mechanism \u03931 is 1 + \u221a k 2 +1 competitive .PROOF .Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs , we can show the competitive ratio by showing that \u03931 is 1 + \u221a k 2 +1 competitive for each interval in the sequence 1 , ... , F .Over an arbitrary interval If , the offline algo \u221a rithm can achieve at most tclose f \u2212 tbegin f \u00b7 k + vf + 1 + k vf , from the two gifts and the net gain bounded by Lemma 9 .Applying Lemma 7 , this quantity is then bounded from \u221a \u221a above by 1 + \u221a 1 k \u00b7 vf \u00b7 k + vf + 1 + k vf = 1 + k 2 +1 \u00b7 vf .Since \u03931 achieves vf , the competitive ratio holds .While so far we have allowed each agent to lie about all four characteristics of its job , lying about the length of the job is not possible in some settings .For example , a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem .Another restriction that is natural in some settings is uniform value densities k = 1 , which was the case considered by 4 .If the setting satisfies these two conditions , then , by using Mechanism \u03932 , we can achieve a competitive ratio of 5 which is the same competitive ratio as \u03931 for the case of k = 1 without knowledge of \u03c1min and without the use of payments .The latter property may be necessary in settings that are more local than grid computing e.g. , within a department but in which the users are still self-interested .7THEOREM 11 .When k = 1 , and each agent i can not falsely declare li , Mechanism \u03932 satisfies individual rationality and incentive compatibility .THEOREM 12 .When k = 1 , and each agent i can not falsely declare li , Mechanism \u03932 is 5-competitive .Since this mechanism is essentially a simplification of \u03931 , we omit proofs of these theorems .Basically , the fact that k = 1 and \u02c6li = li both hold allows \u03932 to substitute the priority li + ei \u02c6\u03b8 , t for the priority used in \u03931 ; and , since \u02c6vi is ignored , payments are no longer needed to ensure incentive compatibility .\u221a We now show that the competitive ratio of 1 + k 2 + 1 achieved by \u03931 is a lower bound for deterministic online mechanisms .To do so , we will appeal to third requirement on a mechanism , non-negative payments NNP , which requires that the center never pays an agent formally , \u2200 i , \u02c6\u03b8 , pi \u02c6\u03b8i \u2265 0 .Unlike IC and IR , this requirement is not standard in mechanism design .We note , however , that both \u03931 and \u03932 satisfy it trivially , and that , in the following proof , zero only serves as a baseline utility for an agent , and could be replaced by any non-positive function of \u02c6 \u03b8 \u2212 i .The proof of the lower bound uses an adversary argument similar to that used in 4 to show a lower bound of 1 + \u221a k 2 in the non-strategic setting , with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments .We first present a lemma relating to the recurrence used for this argument , with the proof omitted due to space constraints .tive ratio less than 1 + k 2 + 1 .PROOF .Assume by contradiction that there exists a deterministic online mechanism \u0393 that satisfies NNP and that \\ / achieves a competitive ratio of c = 1 + k 2 +1 e for some e > 0 and , by implication , satisfies IC and IR as well .Since a competitive ratio of c implies a competitive ratio of c + x , for any x > 0 , we assume without loss of generality that e < 1 .First , we will construct a profile of agent types \u03b8 using an adversary argument .After possibly slightly perturbing \u03b8 to assure that a strictness property is satisfied , we will then use a more significant perturbation of \u03b8 to reach a contradiction .We now construct the original profile \u03b8 .Pick an \u03b1 such that 0 < \u03b1 < e , and define \u03b4 = \u03b1 ck +3 k .The adversary uses two sequences of jobs : minor and major .Minor jobs i are characterized by li = \u03b4 , vi = k \u2022 \u03b4 , and zero laxity .The first minor job is released at time 0 , and ri = di \u2212 1 for all i > 1 .The sequence stops whenever \u0393 completes any job .Major jobs also have zero laxity , but they have the smallest possible value ratio that is , vi = li .The lengths of the major jobs that may be released , starting with i = 1 , are determined by the following recurrence relation .The first major job has a release time of 0 , and each major job i > 1 has a release time of ri = di \u2212 1 \u03b4 , just before the deadline of the previous job .The adversary releases major job i < m if and only if each major job j < i was executed continuously over the range ri , ri +1 .No major job is released after job m .In order to achieve the desired competitive ratio , \u0393 must complete some major job f , because \u0393off line can always at least complete major job 1 for a value of 1 , and \u0393 can complete at most one minor job for a value of \u03b1 c +3 < c1 .Also , in order for this job f to be released , the processor time preceding rf can only be spent executing major jobs that are later abandoned .If f < m , then major job f +1 will be released and it will be the final major job .\u0393 can not complete job f + 1 , because rf + lf = df > rf +1 .Therefore , \u03b8 consists of major jobs 1 through f +1 or , f , if f = m , plus minor jobs from time 0 through time df .We now possibly perturb \u03b8 slightly .By IR , we know that vf > pf \u03b8 .Since we will later need this inequality to be strict , if vf = pf \u03b8 , then change \u03b8f to \u03b8 ~ f , where r ~ f = rf , but v ~ f , l ~ f , and d ~ f are all incremented by \u03b4 over their respective values in \u03b8f .By IC , job f must still be completed by \u0393 for the profile \u03b8 ~ f , \u03b8 \u2212 f .If not , then by IR and NNP we know that pf \u03b8 ~ f , \u03b8 \u2212 f = 0 , and thus that uf g \u03b8 ~ f , \u03b8 \u2212 f , \u03b8 ~ f = 0 .However , agent f could then increase its utility by falsely declaring the original type of \u03b8f , receiving a utility of : uf g \u03b8 ~ f , \u03b8 \u2212 f , \u03b8 ~ f = v ~ f pf \u03b8 = \u03b4 > 0 , violating IC .Furthermore , agent f must be charged the same amount that is , pf \u03b8 ~ f , \u03b8 \u2212 f = pf \u03b8 , due to a similar incentive compatibility argument .Thus , for the remainder of the proof , assume that vf > pf \u03b8 .We now use a more substantial perturbation of \u03b8 to complete the proof .If f < m , then define \u03b8 ~ ~ f to be identical to \u03b8f , except that d ~ ~ f = df +1 + lf , allowing job f to be completely executed after job f +1 is completed .If f = m , then instead set d ~ ~ f = df + lf .IC requires that for the profile \u03b8 ~ ~ f , \u03b8 \u2212 f , \u0393 still executes job f continuously over the range rf , rf + lf , thus preventing job f +1 from being completed .Assume by contradiction that this were not true .Then , at the original deadline of df , job f is not completed .Consider the possible profile \u03b8 ~ ~ f , \u03b8 \u2212 f , \u03b8x , which differs from the new profile only in the addition of a job x which has zero laxity , rx = df , and vx = lx = max d ~ ~ f df , c + 1 \u2022 lf + lf +1 .Because this new profile is indistinguishable from \u03b8 ~ ~ f , \u03b8 \u2212 f to \u0393 before time df , it must schedule jobs in the same way until df .Then , in order to achieve the desired competitive ratio , it must execute job x continuously until its deadline , which is by construction at least as late as the new deadline d ~ ~ f of job f. Thus , job f will not be completed , and , by IR and NNP , it must be the case that pf \u03b8 ~ ~ f , \u03b8 \u2212 f , \u03b8x = 0 and uf g \u03b8 ~ ~ f , \u03b8 \u2212 f , \u03b8x , \u03b8 ~ ~ f = 0 .Using the fact that \u03b8 is indistinguishable from \u03b8f , \u03b8 \u2212 f , \u03b8x up to time df , if agent f falsely declared his type to be the original \u03b8f , then its job would be completed by df and it would be charged pf \u03b8 .Its utility would then increase to uf g \u03b8f , \u03b8 \u2212 f , \u03b8x , \u03b8 ~ ~ f = vf pf \u03b8 > 0 , contradicting IC .While \u0393 's execution must be identical for both \u03b8f , \u03b8 \u2212 f and \u03b8 ~ ~ f , \u03b8 \u2212 f , \u0393off line can take advantage of the change .If f < m , then \u0393 achieves a value of at most lf + \u03b4 the value of job f if it were perturbed , while \u0393off line achieves a value of at least k \u2022 Efh = 1 lh 2\u03b4 + lf +1 + lf by executing minor jobs until rf +1 , followed by job f +1 and then job f we subtract two \u03b4 's instead of one because the last minor job before rf +1 may have to be abandoned .Substituting in for lf +1 , thewhile \u0393offline achieves a value of at least k \u2022 Em If instead f = m , then \u0393 achieves a value of at most lm + \u03b4 ,and then completing job m .The competitive ratio is then", "conclusions": "In this paper , we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found , but for which new solutions were required when the setting is extended to include self-interested agents .We presented a mechanism that is incentive compatible with respect to release time , deadline , length and value , and that only increases the competitive ratio by one .We also showed how this mechanism could be simplified when k = 1 and each agent can not lie about the length of its job .We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents .Several open problems remain in this setting .One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments .Also , while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities k to knowing the actual range of possible value densities , it would be interesting to determine whether there \u221a exists a 1 + k 2 + 1 competitive mechanism under the original assumption .Finally , randomized mechanisms provide an unexplored area for future work .", "related work": "In this section we describe related work other than the two papers 4 and 15 on which this paper is based .Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the offline algorithm see , e.g. , 13 , 14 .Mechanism design was also applied to a scheduling problem in 18 .In their model , the center owns the jobs in an offline setting , and it is the agents who can execute them .The private information of an agent is the time it will require to execute each job .Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem .This paper also launched the area of algorithmic mechanism design , in which the mechanism must satisfy computational requirements in addition to the standard incentive requirements .A growing sub-field in this area is multicast cost-sharing mechanism design see , e.g. , 1 , in which the mechanism must efficiently determine , for each agent in a multicast tree , whether the agent receives the transmission and the price it must pay .For a survey of this and other topics in distributed algorithmic mechanism design , see 9 .Online execution presents a different type of algorithmic challenge , and several other papers study online algorithms or mechanisms in economic settings .For example , 5 considers an online market clearing setting , in which the auctioneer matches buy and sells bids which are assumed to be exogenous that arrive and expire over time .In 2 , a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values .Truthful declaration of values is also considered in 3 and 16 , which both consider multi-unit online auctions .The main difference between the two is that the former considers the case of a digital good , which thus has unlimited supply .It is pointed out in 16 that their results continue to hold when the setting is extended so that bidders can delay their arrival .The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is 11 , which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time .A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent , while a Bayes-Nash IC mechanism is presented for the variant in which the center 's current decision affects the cost of future actions ."}