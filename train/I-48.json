{"reader_keywords": ["normative system game", "multiple goal of increasing priority", "game theoretic property", "kripke structure", "computation tree logic", "ordinal utility", "computational complexity", "nash implementation", "social law", "multi-agent system", "desirable objective", "constraint", "decision making"], "reader_keywords_stem": ["norm system game", "multipl goal of increas prioriti", "game theoret properti", "kripk structur", "comput tree logic", "ordin util", "comput complex", "nash implement", "social law", "multi-agent system", "desir object", "constraint", "decis make"], "introduction": "Normative systems , or social laws , have proved to be an attractive approach to coordination in multi-agent systems 13 , 14 , 10 , 15 , 1 .Although the various approaches to normative systems proposed inthe literature differ on technical details , they all share the same basic intuition that a normative system is a set of constraints on the behaviour of agents in the system ; by imposing these constraints , it is hoped that some desirable objective will emerge .The idea of using social laws to coordinate multi-agent systems was proposed by Shoham and Tennenholtz 13 , 14 ; their approach was extended by van der Hoek et al. to include the idea of specifying a desirable global objective for a social law as a logical formula , with the idea being that the normative system would be regarded as successful if , after implementing it i.e. , after eliminating all forbidden actions , the objective formula was guaranteed to be satisfied in the system 15 .However , this model did not take into account the preferences of individual agents , and hence neglected to account for possible strategic behaviour by agents when deciding whether to comply with the normative system or not .This model of normative systems was further extended by attributing to each agent a single goal in 16 .However , this model was still too impoverished to capture the kinds of decision making that take place when an agent decides whether or not to comply with a social law .In reality , strategic considerations come into play : an agent takes into account not just whether the normative system would be beneficial for itself , but also whether other agents will rationally choose to participate .In this paper , we develop a model of normative systems in which agents are assumed to have multiple goals , of increasing priority .We specify an agent 's goals as a hierarchy of formulae of Computation Tree Logic CTL , a widely used logic for representing the properties of Kripke structures 8 : the intuition is that goals further up the hierarchy are preferred by the agent over those that appear further down the hierarchy .Using this scheme , we define a model of ordinal utility , which in turn allows us to interpret our Kripkebased normative systems as games , in which agents must determine whether to comply with the normative system or not .We thus provide a very natural bridge between logical structures and languages and the techniques and concepts of game theory , which have proved to be very powerful for analysing social contract-style scenarios such as normative systems 3 , 4 .We then characterise the computational complexity of a number of decision problems associated with these Kripke-based normative system games ; for example , we show that the complexity of checking whether there exists a normative system which has the property of being a Nash implementation is NP-complete .", "title": "Normative System Games", "author_keywords_stem": ["normative system", "goal", "logic", "game", "complexity"], "abstract": "We develop a model of normative systems in which agents are assumed to have multiple goals of increasing priority , and investigate the computational complexity and game theoretic properties of this model .In the underlying model of normative systems , we use Kripke structures to represent the possible transitions of a multiagent system .A normative system is then simply a subset of the Kripke structure , which contains the arcs that are forbidden by the normative system .We specify an agent 's goals as a hierarchy of formulae of Computation Tree Logic CTL , a widely used logic for representing the properties of Kripke structures : the intuition is that goals further up the hierarchy are preferred by the agent over those that appear further down the hierarchy .Using this scheme , we define a model of ordinal utility , which in turn allows us to interpret our Kripke-based normative systems as games , in which agents must determine whether to comply with the normative system or not .We then characterise the computational complexity of a number of decision problems associated with these Kripke-based normative system games ; for example , we show that the complexity of checking whether there exists a normative system which has the property of being a Nash implementation is NP-complete .", "id": "I-48", "combined_keywords_stem": ["norm system game", "multipl goal of increas prioriti", "game theoret properti", "kripk structur", "comput tree logic", "ordin util", "comput complex", "nash implement", "social law", "multi-agent system", "desir object", "constraint", "decis make", "norm system", "goal", "logic", "game", "complex"], "combined_keywords": ["normative system game", "multiple goal of increasing priority", "game theoretic property", "kripke structure", "computation tree logic", "ordinal utility", "computational complexity", "nash implementation", "social law", "multi-agent system", "desirable objective", "constraint", "decision making", "normative system", "goal", "logic", "game", "complexity"], "author_keywords": ["normative system", "goal", "logic", "game", "complexity"], "method": "We use Kripke structures as our basic semantic model for multiagent systems 8 .A Kripke structure is essentially a directed graph , with the vertex set S corresponding to possible states of the system being modelled , and the relation R \u2286 S \u00d7 S capturing thepossible transitions of the system ; intuitively , these transitions are caused by agents in the system performing actions , although we do not include such actions in our semantic model see , e.g. , 13 , 2 , 15 for related models which include actions as first class citizens .We let S0 denote the set of possible initial states of the system .Our model is intended to correspond to the well-known interleaved concurrency model from the reactive systems literature : thus an arc corresponds to the execution of an atomic action by one of the processes in the system , which we call agents .It is important to note that , in contrast to such models as 2 , 15 , we are therefore here not modelling synchronous action .This assumption is not in fact essential for our analysis , but it greatly simplifies the presentation .However , we find it convenient to include within our model the agents that cause transitions .We therefore assume a set A of agents , and we label each transition in R with the agent that causes the transition via a function \u03b1 : R \u2192 A. Finally , we use a vocabulary \u03a6 = p , q , ... of Boolean variables to express the properties of individual states S : we use a function V : S \u2192 2\u03a6 to label each state with the Boolean variables true or satisfied in that state .Collecting these components together , an agent-labelled Kripke structure over \u03a6 is a 6-tuple :on .A path \u03c0 such that \u03c0 0 = s is an s-path .Let \u03a0R s denote the set of s-paths over R ; since it will usually be clear from context , we often omit reference to R , and simply write \u03a0 s .We will sometimes refer to and think of an s-path as a possible computation , or system evolution , from s. EXAMPLE 1 .Our running example is of a system with a single non-sharable resource , which is desired by two agents .Consider the Kripke structure depicted in Figure 1 .We have two states , s and t , and two corresponding Boolean variables p1 and p2 , which are 1In the branching time temporal logic literature , a relation R \u2286 S \u00d7 S is said to be total iff \u2200 s \u2203 s ' : s , s ' \u2208 R. Note that the term `` total relation '' is sometimes used to refer to relations R \u2286 S \u00d7 S such that for every pair of elements s , s ' \u2208 S we have either s , s ' \u2208 R or s ' , s \u2208 R ; we are not using the term in this way here .It is also worth noting that for some domains , other constraints may be more appropriate than simple totality .For example , one might consider the agent totality requirement , that in every state , every agent has at least one possible transition available : \u2200 s \u2200 i \u2208 A \u2203 s ' : s , s ' \u2208 R and \u03b1 s , s ' = i.mutually exclusive .Think of pi as meaning `` agent i has currently control over the resource '' .Each agent has two possible actions , when in possession of the resource : either give it away , or keep it .Obviously there are infinitely many different s-paths and t paths .Let us say that our set of initial states S0 equals s , t , i.e. , we do n't make any assumptions about who initially has control over the resource .We now define Computation Tree Logic CTL , a branching time temporal logic intended for representing the properties of Kripke structures 8 .Note that since CTL is well known and widely documented in the literature , our presentation , though complete , will be somewhat terse .We will use CTL to express agents ' goals .The syntax of CTL is defined by the following grammar :where p \u2208 \u03a6 .We denote the set of CTL formula over \u03a6 by L\u03a6 ; since \u03a6 is understood , we usually omit reference to it .The semantics of CTL are given with respect to the satisfaction relation `` | = '' , which holds between pairs of the form K , s , where K is a Kripke structure and s is a state in K , and formulae of the language .The satisfaction relation is defined as follows :K , s | = A \u03d5 U \u03c8 iff \u2200 \u03c0 \u2208 \u03a0 s , \u2203 u \u2208 N , s.t. K , \u03c0 u | = \u03c8 and \u2200 v , 0 \u2264 v < u : K , \u03c0 v | = \u03d5 K , s | = E \u03d5 U \u03c8 iff \u2203 \u03c0 \u2208 \u03a0 s , \u2203 u \u2208 N , s.t. K , \u03c0 u | = \u03c8 and \u2200 v , 0 \u2264 v < u : K , \u03c0 v | = \u03d5 The remaining classical logic connectives `` \u2227 '' , `` \u2192 '' , `` \u2194 '' are assumed to be defined as abbreviations in terms of \u00ac , \u2228 , in the conventional manner .The remaining CTL temporal operators are defined :We say \u03d5 is satisfiable if K , s | = \u03d5 for some Kripke structure K and state s in K ; \u03d5 is valid if K , s | = \u03d5 for all Kripke structures K and states s in K .The problem of checking whether K , s | = \u03d5 for given K , s , \u03d5 model checking can be done in deterministic polynomial time , while checking whether a given \u03d5 is satisfiable or whether \u03d5 is valid is EXPTIME-complete 8 .We write K | = \u03d5 if K , s0 | = \u03d5 for all s0 \u2208 S0 , and | = \u03d5 if K | = \u03d5 for all K.For our purposes , a normative system is simply a set of constraints on the behaviour of agents in a system 1 .More precisely , a normative system defines , for every possible system transition , whether or not that transition is considered to be legal or not .Different normative systems may differ on whether or not a transition is legal .Formally , a normative system \u03b7 w.r.t. a Kripke structure K = ~ S , S0 , R , A , \u03b1 , V ~ is simply a subset of R , such that R \\ \u03b7 is a total relation .The requirement that R \\ \u03b7 is total is a reasonableness constraint : it prevents normative systems which lead to states with no successor .Let N R = \u03b7 : \u03b7 \u2286 R & R \\ \u03b7 is total be the set of normative systems over R .The intended interpretation of a normative system \u03b7 is that s , s ' \u2208 \u03b7 means transition s , s ' is forbidden in the context of \u03b7 ; hence R \\ \u03b7 denotes the legal transitions of \u03b7 .Since it is assumed \u03b7 is reasonable , we are guaranteed that a legal outward transition exists for every state .We denote the empty normative system by \u03b70 , so \u03b70 = \u2205 .Note that the empty normative system \u03b70 is reasonable with respect to any transition relation R .The effect of implementing a normative system on a Kripke structure is to eliminate from it all transitions that are forbidden according to this normative system see 15 , 1 .If K is a Kripke structure , and \u03b7 is a normative system over K , then K \u2020 \u03b7 denotes the Kripke structure obtained from K by deleting transitions forbidden in \u03b7 .Formally , if K = ~ S , S0 , R , A , \u03b1 , V ~ , and \u03b7 \u2208 N R , then let K \u2020 \u03b7 = K ' be the Kripke structure K ' = ~ S ' , S0 ' , R ' , A ' , \u03b1 ' , V ' ~ where :Notice that for all K , we have K \u2020 \u03b70 = K. EXAMPLE 1 .continued When thinking in terms of fairness , it seems natural to consider normative systems \u03b7 that contain s , s or t , t .A normative system with s , t would not be fair , in the sense that AOA \u00ac p1 \u2228 AOA \u00ac p2 holds : in all paths , from some moment on , one agent will have control forever .Let us , for later reference , fix \u03b71 = s , s , \u03b72 = t , t , and \u03b73 = s , s , t , t .Later , we will address the issue of whether or not agents should rationally choose to comply with a particular normative system .In this context , it is useful to define operators on normative systems which correspond to groups of agents `` defecting '' from the normative system .Formally , let K = ~ S , S0 , R , A , \u03b1 , V ~ be a Kripke structure , let C \u2286 A be a set of agents over K , and let \u03b7 be a normative system over K. Then :\u03b7 1 C = s , s ' : s , s ' \u2208 \u03b7 & \u03b1 s , s ' \u2208 ~ C .Thus K \u2020 \u03b7 1 C is the Kripke structure that results if only the agents in C choose not to comply with the normative system i.e. , the only ones who comply are those in A \\ C .Note that we have \u03b7 1 C = \u03b7 A \\ C and \u03b7 C = \u03b7 1 A \\ C .Next , we want to be able to capture the goals that agents have , as these will drive an agent 's strategic considerations particularly , as we will see , considerations about whether or not to comply with a normative system .We will model an agent 's goals as a prioritised list of CTL formulae , representing increasingly desired properties that the agent wishes to hold .The intended interpretation of such a goal hierarchy \u03b3i for agent i \u2208 A is that the `` further up the hierarchy '' a goal is , the more it is desired by i. Note that we assume that if an agent can achieve a goal at a particular level in its goal hierarchy , then it is unconcerned about goals lower down the hierarchy .Formally , a goal hierarchy , \u03b3 , over a Kripke structure K is a finite , non-empty sequence of CTL formulaein which , by convention , \u03d50 = .We use a natural number indexing notation to extract the elements of a goal hierarchy , so if \u03b3 = \u03d50 , \u03d51 , ... , \u03d5k then \u03b3 0 = \u03d50 , \u03b3 1 = \u03d51 , and so on .We denote the largest index of any element in \u03b3 by | \u03b3 | .A particular Kripke structure K is said to satisfy a goal at index x in goal hierarchy \u03b3 if K | = \u03b3 x , i.e. , if \u03b3 x is satisfied in all initial states S0 of K .An obvious potential property of goal hierarchies is monotonicity : where goals at higher levels in the hierarchy logically imply those at lower levels in the hierarchy .Formally , a goal hierarchy \u03b3 is monotonic if for all x \u2208 1 , ... , | \u03b3 | \u2286 N , we have | = \u03b3 x \u2192 \u03b3 x \u2212 1 .The simplest type of monotonic goal hierarchy is where \u03b3 x + 1 = \u03b3 x \u2227 \u03c8x +1 for some \u03c8x +1 , so at each successive level of the hierarchy , we add new constraints to the goal of the previous level .Although this is a natural property of many goal hierarchies , it is not a property we demand of all goal hierarchies .EXAMPLE 1 .continued Suppose the agents have similar , but opposing goals : each agent i wants to keep the source as often and long as possible for himself .Define each agent 's goal hierarchy as :The most desired goal of agent i is to , in every computation , always have the resource , pi this is expressed in \u03d5i8 .Thanks to our reasonableness constraint , this goal implies \u03d5i7 which says that , no matter how the computation paths evolve , it will always be that allcontinuations will hit a point in which pi , and , moreover , there is a continuation in which pi always holds .Goal cpi6 is a fairness constraint implied by it .Note that A \u2666 pi says that every computation eventually reaches a pi state .This may mean that after pi has happened , it will never happen again .cpi6 circumvents this : it says that , no matter where you are , there should be a future pi state .The goal cpi5 is like the strong goal cpi8 but it accepts that this is only achieved in some computation , eventually .cpi4 requires that in every path , there is always a continuation that eventually gives pi .Goal cpi3 says that pi should be true on some branch , from some moment on .It implies cpi2 which expresses that there is a computation such that everywhere during it , it is possible to choose a continuation that eventually satisfies pi .This implies cpi 1 , which says that pi should at least not be impossible .If we even drop that demand , we have the trivial goal cpi 0 .We remark that it may seem more natural to express a fairness constraint cpi6 as A \u2666 pi .However , this is not a proper CTL formula .It is in fact a formula in CTL ' 9 , and in this logic , the two expressions would be equivalent .However , our basic complexity results in the next sections would not hold for the richer language CTL ' 2 , and the price to pay for this is that we have to formulate our desired goals in a somewhat more cumbersome manner than we might ideally like .Of course , our basic framework does not demand that goals are expressed in CTL ; they could equally well be expressed in CTL ' or indeed ATL 2 as in 15 .We comment on the implications of alternative goal representations at the conclusion of the next section .A multi-agent system collects together a Kripke structure representing the basic properties of a system under consideration : its state space , and the possible state transitions that may occur in it , together with a goal hierarchy , one for each agent , representing the aspirations of the agents in the system .Formally , a multi-agent system , M , is an n + 1 tuple :where K is a Kripke structure , and for each agent i in K , \u03b3i is a goal hierarchy over K.We can now define the utility of a Kripke structure for an agent .The idea is that the utility of a Kripke structure is the highest index of any goal that is guaranteed for that agent in the Kripke structure .We make this precise in the function ui \u00b7 :Note that using these definitions of goals and utility , it never makes sense to have a goal cp at index n if there is a logically weaker goal 0 at index n + k in the hierarchy : by definition of utility , it could never be n for any structure K.Notice that since for any goal hierarchy \u03b3i we have \u03b3 0 = T , then for all Kripke structures , ui K is well defined , with ui K > 2 CTL ' model checking is PSPACE-complete , and hence much worse under standard complexity theoretic assumptions than model checking CTL 8 .0 .Note that this is an ordinal utility measure : it tells us , for any given agent , the relative utility of different Kripke structures , but utility values are not on some standard system-wide scale .The fact that ui K1 > ui K2 certainly means that i strictly prefers K1 over K2 , but the fact that ui K > uj K does not mean that i values K more highly than j. Thus , it does not make sense to compare utility values between agents , and so for example , some system wide measures of utility , notably those measures that aggregate individual utilities , such as social welfare , do not make sense when applied in this setting .However , as we shall see shortly , other measures such as Pareto efficiency can be usefully applied .There are other representations for goals , which would allow us to define cardinal utilities .The simplest would be to specify goals \u03b3 for an agent as a finite , non-empty , one-to-one relation : \u03b3 C G xR .We assume that the x values in pairs cp , x E \u03b3 are specified so that x for agent i means the same as x for agent j , and so we have cardinal utility .We then define the utility for i of a Kripke structure K asui K = max x : cp , x E \u03b3i & K | = cp .The results of this paper in fact hold irrespective of which of these representations we actually choose ; we fix upon the goal hierarchy approach in the interests of simplicity .Our next step is to show how , in much the same way , we can lift the utility function from Kripke structures to normative systems .Suppose we are given a multi-agent system M = K , \u03b31 , ... , \u03b3n and an associated normative system 77 over K. Let for agent i , Si K , K ' be the difference in his utility when moving from K to K ' : Si K , K ' = ui K ' \u2212 ui K .Then the utility of 77 to agent i wrt K is Si K , K \u2020 77 .We will sometimes abuse notation and just write Si K , 77 for this , and refer to it as the benefit for agent i of implementing 77 in K. Note that this benefit can be negative .Summarising , the utility of a normative system to an agent is the difference between the utility of the Kripke structure in which the normative system was implemented and the original Kripke structure .If this value is greater than 0 , then the agent would be better off if the normative system were imposed , while if it is less than 0 then the agent would be worse off if 77 were imposed than in the original system .We say 77 is individually rational for i wrt K if Si K , 77 > 0 , and individually rational simpliciter if 77 is individually rational for every agent .A social system now is a pairKeeping in mind that a norm \u03b7 restricts the possible transitions of the model under consideration , we make the following observation , borrowing from 15 .Some classes of goals are monotonic or anti-monotonic with respect to adding additional constraints to a system .Let us therefore define two fragments of the language of CTL : the universal language Lu with typical element \u03bc , and the existential fragment Le with typical element \u03b5 .Let us say , for two Kripke structures K1 = S , S0 , R1 , A , \u03b1 , V and K2 = S , S0 , R2 , A , \u03b1 , V that K1 is a subsystem of K2 and K2 is a supersystem of K1 , written K1 C K2 iff R1 \u2286 R2 .Note that typically K \u2020 \u03b7 C K .Then we have cf. 15 .This has the following effect on imposing a new norm :Corollary 1 's first item says that an agent whose current maximal goal in a system is a universal formula , need never fear the imposition of a new norm \u03b7 .The reason is that his current goal will at least remain true in fact a goal higher up in the hierarchy may become true .It follows from this that an agent with only universal goals can only gain from the imposition of normative systems \u03b7 .The opposite is true for existential goals , according to the second item of the corollary : it can never be bad for an agent to `` undo '' a norm \u03b7 .Hence , an agent with only existential goals might well fear any norm \u03b7 .However , these observations implicitly assume that all agents in the system will comply with the norm .Whether they will in fact do so , of course , is a strategic decision : it partly depends on what the agent thinks that other agents will do .This motivates us to consider normative system games .We now have a principled way of talking about the utility of normative systems for agents , and so we can start to apply the technical apparatus of game theory to analyse them .Suppose we have a multi-agent system M = K , \u03b31 , ... , \u03b3n and a normative system \u03b7 over K .It is proposed to the agents in M that \u03b7 should be imposed on K , typically to achieve some coordination objective .Our agent let 's say agent i is then faced with a choice : should it comply with the strictures of the normative system , or not ?Note that this reasoning takes place before the agent is `` in '' the system it is a design time consideration .We can understand the reasoning here as a game , as follows .A game in strategic normal form cf. 11 , p. 11 is a structure :If S is a tuple of strategies , one for each agent , and x E C , D , then we denote by A0xS the subset of agents that play strategy x in S. Hence , for a social system \u03a3 = M , \u03b7 , the normative system \u03b7 A0CS only implements the restrictions for those agents that choose to cooperate in 0\u03a3 .Note that this is the same as \u03b7 1 A0DS : the normative system that excludes all the restrictions of agents that play D in 0\u03a3 .We then define the utility functions Ui for eachSo , for example , if SD is a collection of strategies in which every agent defects i.e. , does not comply with the norm , then Ui SD = \u03b4i K , \u03b7 1 A0D SD = ui K \u2020 \u03b70 \u2212 ui K = 0 .In the same way , if SC is a collection of strategies in which every agent cooperates i.e. , complies with the norm , then Ui SC = \u03b4i K , \u03b7 1 A0DSC = ui K \u2020 \u03b7 1 \u2205 = ui K \u2020 \u03b7 .We can now start to investigate some properties of normative system games .A normative system is individually rational if every agent would fare better if the normative system were imposed than otherwise .This is a necessary , although not sufficient condition on a norm to expect that everybody respects it .Note that \u03b73 of our example is individually rational for both 1 and 2 , although this is not a stable situation : given that the other plays C , i is better of by playing D .We can easily characterise individually rationality with respect to the corresponding game in strategic form , as follows .Let \u03a3 = M , \u03b7 be a social system .Then the following are equivalent :The decision problem associated with individually rational normative systems is as follows :Given : Multi-agent system M .Question : Does there exist an individually rational normative system for M ?THEOREM 2 .IRNS is NP-complete , even in one-agent systems .PROOF .For membership of NP , guess a normative system \u03b7 , and verify that it is individually rational .Since \u03b7 C R , we will be able to guess it in nondeterministic polynomial time .To verify that it is individually rational , we check that for all i , we have ui K t \u03b7 > ui K ; computing K t \u03b7 is just set subtraction , so can be done in polynomial time , while determining the value of ui K for any K can be done with a polynomial number of model checking calls , each of which requires only time polynomial in the K and \u03b3 .Hence verifying that ui K t \u03b7 > ui K requires only polynomial time .For NP-hardness , we reduce SAT 12 , p. 77 .Given a SAT instance \u03d5 over Boolean variables x1 , ... , xk , we produce an instance of IRNS as follows .First , we define a single agent A = 1 .For each Boolean variable xi in the SAT instance , we create two Boolean variables t xi and f xi in the IRNS instance .We then create a Kripke structure K\u03d5 with 2k + 1 states , as shown in Figure 3 : arcs in this graph correspond to transitions in K\u03d5 .Let \u03d5 * be the result of systematically substituting for every Boolean variable xi in \u03d5 the CTL expression E \u2762 t xi .Next , consider the following formulae :We then define the goal hierarchy for all agent 1 as follows :We claim there is an individually rational normative system for the instance so constructed iff \u03d5 is satisfiable .First , notice that any individually rational normative system must force \u03b31 1 to be true , since in the original system , we do not have \u03b31 1 .For the = * direction , if there is an individually rational normative system \u03b7 , then we construct a satisfying assignment for \u03d5 by considering the arcs that are forbidden by \u03b7 : formula 1 ensures that we must forbid an arc to either a t xi or a f xi state for all variables xi , but 2 ensures that we can not forbid arcs to both .So , if we forbid an arc to a t xi state then in the corresponding valuation for \u03d5 we make xi false , while if we forbid an arc to a f xi state then we make xi true .The fact that \u03d5 * is part of the goal ensures that the normative system is indeed a valuation for \u03d5 .For , note that for any satisfying valuation for \u03d5 we can construct an individually rational normative system \u03b7 , as follows : if the valuation makes xi true , we forbid the arc to the f xi state , while if the valuation makes xi false , we forbid the arc to the t xi state .The resulting normative system ensures \u03b31 1 , and is thus individually rational .Notice that the Kripke structure constructed in the reduction contains just a single agent , and so the Theorem is proven .Pareto efficiency is a basic measure of how good a particular outcome is for a group of agents 11 , p. 7 .Intuitively , an outcome is Pareto efficient if there is no other outcome that makes every agent better off .In our framework , suppose we are given a social system \u03a3 = M , \u03b7 , and asked whether \u03b7 is Pareto efficient .This amounts to asking whether or not there is some other normative system \u03b7 ' such that every agent would be better off under \u03b7 ' than with \u03b7 .If \u03b7 ' makes every agent better off than \u03b7 , then we say \u03b7 ' Pareto dominates \u03b7 .The decision problem is as follows :Given : Multi-agent system M and normative system \u03b7 over M .Question : Is \u03b7 Pareto efficient for M ?THEOREM 3 .PENS is co-NP-complete , even for one-agent systems .PROOF .Let M and \u03b7 be as in the Theorem .We show that the complement problem to PENS , which we refer to as PARETO DOMINATED , is NP-complete .In this problem , we are given M and \u03b7 , and we are asked whether \u03b7 is Pareto dominated , i.e. , whether or not there exists some \u03b7 ' over M such that \u03b7 ' makes every agent better off than \u03b7 .For membership of NP , simply guess a normative system \u03b7 ' , and verify that for all i E A , we have ui K t \u03b7 ' > ui K t \u03b7 verifying requires a polynomial number of model checking problems , each of which takes polynomial time .Since \u03b7 ' C R , the normative system can be guessed in non-deterministic polynomial time .For NP-hardness , we reduce IRNS , which we know to be NPcomplete from Theorem 2 .Given an instance M of IRNS , we let M in the instance of PARETO DOMINATED be as in the IRNS instance , and define the normative system for PARETO DOMINATED to be \u03b70 , the empty normative system .Now , it is straightforward that there exists a normative system \u03b7 ' which Pareto dominates \u03b70 in M iff there exist an individually rational normative system in M .Since the complement problem is NP-complete , it follows that PENS is co-NP-complete .How about Pareto efficient norms for our toy example ?Settling this question amounts to finding the dominant normative systems among 770 = 770 , 771 , 772 , 773 defined before , and 774 = s , t , 775 = t , s , 776 = s , s , t , s , 777 = t , t , s , t and 778 = s , t , t , s .The utilities for each system are given in Table 1 .From this , we infer that the Pareto efficient norms are 771 , 772 , 773 , 776 and 777 .Note that 778 prohibits the resource to be passed from one agent to another , and this is not good for any agent since we have chosen S0 = s , t , no agent can be sure to ever get the resource , i.e. , goal Wi1 is not true in K \u2020 778 .The most famous solution concept in game theory is of course Nash equilibrium 11 , p. 14 .A collection of strategies , one for each agent , is said to form a Nash equilibrium if no agent can benefit by doing anything other than playing its strategy , under the assumption that the other agents play theirs .Nash equilibria are important because they provide stable solutions to the problem of what strategy an agent should play .Note that in our toy example , although 773 is individually rational for each agent , it is not a Nash equilibrium , since given this norm , it would be beneficial for agent 1 to deviate and likewise for 2 .In our framework , we say a social system \u03a3 = M , 77 where 77 = ~ 770 is a Nash implementation if SC i.e. , everyone complying with the normative system forms a Nash equilibrium in the game 9\u03a3 .The intuition is that if \u03a3 is a Nash implementation , then complying with the normative system is a reasonable solution for all concerned : there can be no benefit to deviating from it , indeed , there is a positive incentive for all to comply .If \u03a3 is not a Nash implementation , then the normative system is unlikely to succeed , since compliance is not rational for some agents .Our choice of terminology is deliberately chosen to reflect the way the term `` Nash implementation '' is used in implementation theory , or mechanism design 11 , p. 185 , where a game designer seeks to achieve some outcomes by designing the rules of the game such that these outcomes are equilibria .NASH IMPLEMENTATION NI : Given : Multi-agent system M .Question : Does there exist a non-empty normative system 77 over M such that M , 77 forms a Nash implementation ?Verifying that a particular social system forms a Nash implementation can be done in polynomial time it amounts to checking :This , clearly requires only a polynomial number of model checking calls , each of which requires only polynomial time .THEOREM 4 .The NI problem is NP-complete , even for twoagent systems .PROOF .For membership of NP , simply guess a normative system 77 and check that it forms a Nash implementation ; since 77 C R , guessing can be done in non-deterministic polynomial time , and aswe argued above , verifying that it forms a Nash implementation can be done in polynomial time .For NP-hardness , we reduce SAT .Suppose we are given a SAT instance W over Boolean variables x1 , ... , xk .Then we construct an instance of NI as follows .We create two agents , A = 1 , 2 .For each Boolean variable xi we create two Boolean variables , t xi and f xi , and we then define a Kripke structure as shown in Figure 4 , with s0 being the only initial state ; the arc labelling in Figure 4 gives the \u03b1 function , and each state is labelled with the propositions that are true in that state .For each Boolean variable xi , we define the formulae xi ~ and xi \u22a5 as follows :Let W * be the formula obtained from W by systematically substituting xi ~ for xi .Each agent has three goals : yi 0 = T for both i E 1 , 2 , whileand finally , for both agents , yi 2 being the conjunction of the following formulae :We denote the multi-agent system so constructed by M\u03d5 .Now , we prove that the SAT instance W is satisfiable iff M\u03d5 has a Nash implementation normative system : For the = * direction , suppose W is satisfiable , and let X be a satisfying valuation , i.e. , a set of Boolean variables making W true .We can extract from X a Nash implementation normative system 77 as follows : if xi E X , then 77 includes the arc from so to the state in which f xi is true , and also includes the arc from s 2k + 1 to the state in which f xi is true ; if xi E ~ X , then 77 includes the arc from so to the state in which t xi is true , and also includes the arc from s 2k + 1 to the state in which t xi is true .No other arcs , apart from those so defined , as included in 77 .Notice that 77 is individually rational for both agents : if they both comply with the normative system , then they will have their yi 2 goals achieved , which they do not in the basic system .To see that 77 forms a Nash implementation , observe that if either agent defects from 77 , then neither will have their yi 2 goals achieved : agent 1 strictly prefers C , C over D , C , and agent 2 strictly prefers C , C over C , D .For the t = direction , suppose there exists a Nash implementation normative system 77 , in which case 77 = ~ 0 .Then W is satisfiable ; for suppose not .Then the goals yi 2 are not achievable by any normative system , by construction .Now , since 77 must forbid at least one transition , then at least one agent would fail to have its yi 1 goal achieved if it complied , so at least one would do better by defecting , i.e. , not complying with 77 .But this contradicts the assumption that 77 is a Nash implementation , i.e. , that C , C forms a Nash equilibrium .This result is perhaps of some technical interest beyond the specific concerns of the present paper , since it is related to two problems that are of wider interest : the complexity of mechanism design 5 , and the complexity of computing Nash equilibria 6 , 7It is interesting to consider what happens to the complexity of the problems we consider above if we allow richer languages for goals : in particular , CTL ' 9 .The main difference is that determining ui K in a given multi-agent system M when such a goal language is used involves solving a PSPACE-complete problem since model checking for CTL ' is PSPACE-complete 8 .In fact , it seems that for each of the three problems we consider above , the corresponding problem under the assumption of a CTL ' representation for goals is also PSPACE-complete .It can not be any easier , since determining the utility of a particular Kripke structure involves solving a PSPACE-complete problem .To see membership in PSPACE we can exploit the fact that PSPACE = NPSPACE 12 , p. 150 , and so we can `` guess '' the desired normative system , applying a PSPACE verification procedure to check that it has the desired properties .", "conclusions": "Social norms are supposed to restrict our behaviour .Of course , such a restriction does not have to be bad : the fact that an agent 's behaviour is restricted may seem a limitation , but there may be benefits if he can assume that others will also constrain their behaviour .The question then , for an agent is , how to be sure that others will comply with a norm .And , for a system designer , how to be sure that the system will behave socially , that is , according to its norm .Game theory is a very natural tool to analyse and answer these questions , which involve strategic considerations , and we have proposed a way to translate key questions concerning logic-based normative systems to game theoretical questions .We have proposed a logical framework to reason about such scenarios , and we have given some computational costs for settling some of the main questions about them .Of course , our approach is in many senses open for extension or enrichment .An obvious issue is to consider is the complexity of the questions we give for more practical representations of models cf. 1 , and to consider other classes of allowable goals ."}