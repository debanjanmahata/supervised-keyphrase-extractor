{"abstract": "We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem .The bidding language in our auctions allows marginal-decreasing piecewise constant curves .First , we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem , which computes a 1 + e approximation in worst-case time T = O n3/e , given n bids each with a constant number of pieces .Second , we embed this approximation scheme within a Vickrey-Clarke-Groves VCG mechanism and compute payments to n agents for an asymptotic cost of O T log n .The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by e / 1 + e V , where V is the total surplus in the efficient outcome .", "id": "J-28", "reader_keywords_stem": ["approxim-effici and approximatelystrategyproof auction mechan", "singl-good multi-unit alloc problem", "fulli polynomi-time approxim scheme", "vickrei-clark-grove", "forward auction", "revers auction", "equilibrium", "margin-decreas piecewis constant curv", "bid languag", "dynam program"], "combined_keywords_stem": ["approxim-effici and approximatelystrategyproof auction mechan", "singl-good multi-unit alloc problem", "fulli polynomi-time approxim scheme", "vickrei-clark-grove", "forward auction", "revers auction", "equilibrium", "margin-decreas piecewis constant curv", "bid languag", "dynam program", "approxim algorithm", "multi-unit auction", "strategyproof"], "introduction": "In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem .Our scheme is both approximately efficient and approximately strategyproof .The auction settings considered in our paper are motivated by recent trends in electronic commerce ; for instance , corporations are increasingly using auctions for their strategic sourcing .We consider both a reverse auction variation and a forward auction variation , and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves .In the reverse auction , we consider a single buyer with a demand for M units of a good and n suppliers , each with a marginal-decreasing piecewise-constant cost function .In addition , each supplier can also express an upper bound , or capacity constraint on the number of units she can supply .The reverse variation models , for example , a procurement auction to obtain raw materials or other services e.g. circuit boards , power suppliers , toner cartridges , with flexible-sized lots .In the forward auction , we consider a single seller with M units of a good and n buyers , each with a marginal-decreasing piecewise-constant valuation function .A buyer can also express a lower bound , or minimum lot size , on the number of units she demands .The forward variation models , for example , an auction to sell excess inventory in flexible-sized lots .We consider the computational complexity of implementing the Vickrey-Clarke-Groves 22 , 5 , 11 mechanism for the multiunit auction problem .The Vickrey-Clarke-Groves VCG mechanism has a number of interesting economic properties in this setting , including strategyproofness , such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction , and allocative efficiency , such that the outcome maximizes the total surplus in the system .However , as we discuss in Section 2 , the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer .Otherwise , either the auction must run at a loss in these instances , or the buyer can not be expected to voluntarily choose to participate .This is an example of the budget-deficit problem that often occurs in efficient mechanism design 17 .The computational problem is interesting , because even with marginal-decreasing bid curves , the underlying allocation problem turns out to weakly intractable .For instance , the classic 0/1 knapsack is a special case of this problem .1 We model the 1However , the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and allallocation problem as a novel and interesting generalization of the classic knapsack problem , and develop a fully polynomialtime approximation scheme , computing a 1 + ~ approximation in worst-case time T = O n3 / \u03b5 , where each bid has a fixed number of piecewise constant pieces .Given this scheme , a straightforward computation of the VCG payments to all n agents requires time O nT .We compute approximate VCG payments in worst-case time O \u03b1T log \u03b1n / \u03b5 , where \u03b1 is a constant that quantifies a reasonable `` no-monopoly '' assumption .Specifically , in the reverse auction , suppose that C _ T is the minimal cost for procuring M units with all sellers _ T , and C _ T \\ i is the minimal cost without seller i. Then , the constant \u03b1 is defined as an upper bound for the ratio C _ T \\ i / C _ T , over all sellers i .This upper-bound tends to 1 as the number of sellers increases .The approximate VCG mechanism is \u03b5 1 + \u03b5 strategyproof for an approximation to within 1 + ~ of the optimal allocation .This means that a bidder can gain at most \u03b5 1 + \u03b5 V from a nontruthful bid , where V is the total surplus from the efficient allocation .As such , this is an example of a computationally-tractable \u03b5-dominance result .2 In practice , we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation .Section 2 formally defines the forward and reverse auctions , and defines the VCG mechanisms .We also prove our claims about \u03b5-strategyproofness .Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme .Section 4 defines the approximation scheme for the payments in the VCG mechanism .Section 5 concludes .", "title": "Approximately-Strategyproof and Tractable Multi-Unit Auctions", "method": "In this section , we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions .Continuing , we introduce the VCG mechanism for the problem and the \u03b5-dominance results for approximations to VCG outcomes .We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings .We provide a piecewise-constant and marginal-decreasing bidding language .This bidding language is expressive for a natural class of valuation and cost functions : fixed unit prices over intervals of quantities .See Figure 1 for an example .In addition , we slightly relax the marginal-decreasing requirement to allow : a bidder in the forward auction to state a minimal purchase amount , such that she has zero value for quantities smaller than that amount ; a seller in the reverse auction to state a capacity constraint , such that she has an effectively infinite cost to supply quantities in excess of a particular amount .Figure 1 : Marginal-decreasing , piecewise constant bids .In the forward auction bid , the bidder offers $ 10 per unit for quantity in the range 5 , 10 , $ 8 per unit in the range 10 , 20 , and $ 7 in the range 20 , 25 .Her valuation is zero for quantities outside the range 10 , 25 .In the reverse auction bid , the cost of the seller is \u221e outside the range 10 , 25 .In detail , in a forward auction , a bid from buyer i can be written as a list of quantity-range , unit-price tuples , u1i , p1i ,i on the quantity .The interpretation is that the bidder 's valuation in thesemi-open quantity range uji , uj +1 i is pji for each unit .Additionally , it is assumed that the valuation is 0 for quantities less than u1i as well as for quantities more than umi .This is implemented by adding two dummy bid tuples , with zero prices in the range 0 , u1i and umi i , \u221e .We interpret the bid list as defining a price function , pbid , i q = qpji , if uji < q < uj +1A seller 's bid is similarly defined in the reverse auction .The interpretation is that the bidder 's cost in the semi-open quantity range uji , uj +1 i is pji for each unit .Additionally , it is assumed that the cost is \u221e for quantities less than u1i as well as for quantities more than umi .Equivalently , the unit prices in the ranges 0 , u1i and umi , \u221e are infinity .We interpret the bid list as defining a price function , pask , i q = qpji , if uji < q < uj +1 i .We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism .We assume that all agents have quasilinear utility functions ; that is , ui q , p = vi q \u2212 p , for a buyer i with valuation vi q for q units at price p , and ui q , p = p \u2212 ci q for a seller i with cost ci q at price p .This is a standard assumption in the auction literature , equivalent to assuming risk-neutral agents 13 .We will use the term payoff interchangeably for utility .In the forward auction , there is a seller with M units to sell .We assume that this seller has no intrinsic value for the items .Given a set of bids from I agents , let V I denote the maximal revenue to the seller , given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold .Let x * = x * 1 , ... , x * N denote the solution to this winner determination problem , where x * i is the number of units sold to agent i. Similarly , let V I \\ i denote the maximal revenue to the seller without bids from agent i .The VCG mechanism is defined as follows :In this forward auction , the VCG mechanism is strategyproof for buyers , which means that truthful bidding is a dominant strategy , i.e. utility maximizing whatever the bids of other buyers .In addition , the VCG mechanism is allocatively-efficient , and the payments from each buyer are always positive .3 Moreover , each buyer pays less than its value , and receives payoff V I \u2212 V I \\ i in equilibrium ; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system .In the reverse auction , there is a buyer with M units to buy , and n suppliers .We assume that the buyer has value V > 0 to purchase all M units , but zero value otherwise .To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism .4 The winneran efficient trading mechanism in this setting .determination problem in the reverse auction is to determine the allocation , x * , that minimizes the cost to the buyer , or forfeits trade if the minimal cost is greater than value , V .Let C I denote the minimal cost given bids from all sellers , and let C I \\ i denote the minimal cost without bids from seller i .We can assume , without loss of generality , that there is an efficient trade and V > C I .Otherwise , then the efficient outcome is no trade , and the outcome of the VCG mechanism is no trade and no payments .The VCG mechanism implements the outcome x * that minimizes cost based on bids from all sellers , and then provides payment pvcg , i = pask , i x * i + V \u2212 C I \u2212 max 0 , V \u2212 C I \\ i to each seller .The total payment is collected from the buyer .Again , in equilibrium each seller 's payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system ; in the simple case that V > C I \\ i for all sellers i , this is precisely C I \\ i \u2212 C I .Although the VCG mechanism remains strategyproof for sellers in the reverse direction , its applicability is limited to cases in which the total payments to the sellers are less than the buyer 's value .Otherwise , there will be instances in which the buyer will not choose to voluntarily participate in the mechanism , based on its own value and its beliefs about the costs of sellers .This leads to a loss in efficiency when the buyer chooses not to participate , because efficient trades are missed .This problem with the size of the payments , does not occur in simple single-item reverse auctions , or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures .5 Intuitively , the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items , and has zero value without them .This leads to the possibility of the trade being contingent on the presence of particular , so-called `` pivotal '' sellers .Define a seller i as pivotal , if C I < V but C I \\ i > V .In words , there would be no efficient trade without the seller .Any time there is a pivotal seller , the VCG payments to that seller allow her to extract all of the surplus , and the payments are too large to sustain with the buyer 's value unless this is the only winning seller .Concretely , we have this participation problem in the reverse auction when the total payoff to the sellers , in equilibrium , exceeds the total payoff from the efficient allocation :As stated above , first notice that we require V > C I \\ i for all sellers i .In other words , there must be no pivotal sellers .Given this , it is then necessary and sufficient that :5To make the reverse auction symmetric with the forward direction , we would need a buyer with a constant marginal-value to buy the first M units , and zero value for additional units .The payments to the sellers would never exceed the buyer 's value in this case .Conversely , to make the forward auction symmetric with the reverse auction , we would need a seller with a constant and high marginal-cost to sell anything less than the first M units , and then a low or zero marginal cost .The total payments received by the seller can be less than the seller 's cost for the outcome in this case .In words , the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller .6 Consider an example with 3 agents f1 , 2 , 3 , and V = 150 and C 123 = 50 .Condition 1 holds when C 12 = C 23 = 70 and C 13 = 100 , but not when C 12 = C 23 = 80 and C 13 = 100 .In the first case , the agent payoffs \u03c0 = \u03c00 , \u03c01 , \u03c02 , \u03c03 , where 0 is the seller , is 10 , 20 , 50 , 20 .In the second case , the payoffs are \u03c0 = \u2212 10 , 30 , 50 , 30 .One thing we do know , because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms 14 , is that whenever Eq .1 is not satisfied there can be no efficient auction mechanism .7We now consider the same VCG mechanism , but with an approximation scheme for the underlying allocation problem .We derive an \u03b5-strategyproofness result , that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy .We describe the result for the forward auction direction , but it is quite a general observation .As before , let V Z denote the value of the optimal solution to the allocation problem with truthful bids from all agents , and V Z \\ i denote the value of the optimal solution computed without bids from agent i. Let V\u02c6 Z and V\u02c6 Z \\ i denote the value of the allocation computed with an approximation scheme , and assume that the approximation satisfies :for some ~ > 0 .We provide such an approximation scheme for our setting later in the paper .Let x\u02c6 denote the allocation implemented by the approximation scheme .The payoff to agent i , for announcing valuation \u02c6vi , is :The final term is independent of the agent 's announced value , and can be ignored in an incentive-analysis .However , agent i can try to improve its payoff through the effect of its announced value on the allocation x\u02c6 implemented by the mechanism .In particular , agent i wants the mechanism to select x\u02c6 to maximize the sum of its true value , vi \u02c6xi , and the reported value of the other agents , Ej ~ = i \u02c6vj \u02c6xj .If the mechanism 's allocation algorithm is optimal , then all the agent needs to do is truthfully state its value and the mechanism will do the rest .However , faced with an approximate allocation algorithm , the agent can try to improve its payoff by announcing a value that corrects for the approximation , and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value 18 .6This condition is implied by the agents are substitutes requirement 3 , that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium .Useful characterizations of conditions that satisfy agents are substitutes , in terms of the underlying valuations of agents have proved quite elusive .7Moreover , although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance i.e. with the mechanism neither introducing or removing money , analytic results are only known for simple problems e.g. 16 , 4 .We can now analyze the best possible gain from manipulation to an agent in our setting .We first assume that the other agents are truthful , and then relax this .In both cases , the maximal benefit to agent i occurs when the initial approximation is worst-case .With truthful reports from other agents , this occurs when the value of choice x\u02c6 is V Z / 1 + \u03b5 .Then , an agent could hope to receive an improved payoff of : V Z \u03b5This is possible if the agent is able to select a reported type to correct the approximation algorithm , and make the algorithm implement the allocation with value V Z .Thus , if other agents are truthful , and with a 1 + \u03b5 approximation scheme to the allocation problem , then no agent can improve its payoff by more than a factor \u03b5 / 1 + \u03b5 of the value of the optimal solution .The analysis is very similar when the other agents are not truthful .In this case , an individual agent can improve its payoff by no more than a factor ~ / 1 + ~ of the value of the optimal solution given the values reported by the other agents .Let V in the following theorem define the total value of the efficient allocation , given the reported values of agents j = ~ i , and the true value of agent i.Notice that we did not need to bound the error on the allocation problems without each agent , because the ~ strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term .However , the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism .In this section , we design a fully polynomial approximation scheme for the generalized knapsack , which models the winnerdetermination problem for the VCG-based multi-unit auctions .We describe our results for the reverse auction variation , but the formulation is completely symmetric for the forward-auction .In describing our approximation scheme , we begin with a simple property the Anchor property of an optimal knapsack solution .We use this property to develop an O n2 time 2-approximation for the generalized knapsack .In turn , we use this basic approximation to develop our fully polynomial-time approximation scheme FPTAS .One of the major appeals of our piecewise bidding language is its compact representation of the bidder 's valuation functions .We strive to preserve this , and present an approximation scheme that will depend only on the number of bidders , and not the maximum quantity , M , which can be very large in realistic procurement settings .The FPTAS implements an 1 + \u03b5 approximation to the optimal solution x \u2217 , in worst-case time T = O n3 / \u03b5 , where n is the number of bidders , and where we assume that the piecewise bid for each bidder has O 1 pieces .The dependence on the number of pieces is also polynomial : if each bid has a maximumof c pieces , then the running time can be derived by substituting nc for each occurrence of n.Before we begin , let us recall the classic 0/1 knapsack problem : we are given a set of n items , where the item i has value vi and size si , and a knapsack of capacity M ; all sizes are integers .The goal is to determine a subset of items of maximum value with total size at most M .Since we want to focus on a reverse auction , the equivalent knapsack problem will be to choose a set of items with minimum value i.e. cost whose size exceeds M .The generalized knapsack problem of interest to us can be defined as follows :Instance : A target M , and a set of n lists , where the ith list has the formwhere uj i are increasing with j and pji are decreasing with j , and uji , pji , M are positive integers .This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack .In the latter , each list consists of a single point si , vi .8 The connection between the generalized knapsack and our auction problem is transparent .Each list encodes a bid , representing multiple mutually exclusive quantity intervals , and one can choose any quantity in an interval , but at most one interval can be selected .Choosing interval uji , uj +1 i has cost pji per unit .The goal is to procure at least M units of the good at minimum possible cost .The problem has some flavor of the continuous knapsack problem .However , there are two major differences that make our problem significantly more difficult : 1 intervals have boundaries , and so to choose interval uji , uj +1 i requires that at least uji and at most uj +1 i units must be taken ; 2 unlike the classic knapsack , we can not sort the items bids by value/size , since different intervals in one list have different unit costs .We begin with a definition .Given an instance of the generalized knapsack , we call each tuple tji = uji , pji an anchor .Recall that these tuples represent the breakpoints in the piecewise constant curve bids .We say that the size of an anchor tji is uji , 8In fact , because of the `` one per list '' constraint , the generalized problem is closer in spirit to the multiple choice knapsack problem 9 , where the underling set of items is partitioned into disjoint subsets U1 , U2 , ... , Uk , and one can choose at most one item from each subset .PTAS do exist for this problem 10 , and indeed , one can convert our problem into a huge instance of the multiple choice knapsack problem , by creating one group for each list ; put a quantity , price point tuple x , p for each possible quantity for a bidder into his group subset .However , this conversion explodes the problem size , making it infeasible for all but the most trivial instances .the minimum number of units available at this anchor 's price pji .The cost of the anchor tji is defined to be the minimum total price associated with this tuple , namely , cost tji = pji uji if j < mi , and cost tmiIn a feasible solution x1 , x2 , ... , xn of the generalized knapsack , we say that an element xi = ~ 0 is an anchor if xi = uji , for some anchor uji .Otherwise , we say that xi is midrange .We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange .If there are two midrange elements x and x ' , for bids from two different agents , with x < x ' , then we can increment x ' and decrement x , until one of them becomes an anchor .See Figure 2 for an example .We use the anchor property to first obtain a polynomial-time 2-approximation scheme .We do this by solving several instances of a restricted generalized-knapsack problem , which we call iKnapsack , where one element is forced to be midrange for a particular interval .Specifically , suppose element x ~ for agent l is forced to lie in its jth range , uj ~ , uj +1 ~ , while all other elements , x1 , ... , xl \u2212 1 , xl +1 , xn , are required to be anchors , or zero .This corresponds to the restricted problem iKnapsack f , j , in which the goal is to obtain at least M uj ~ units with minimum cost .Element x ~ is assumed to have already contributed uj ~ units .The value of a solution to iKnapsack f , j represents the minimal additional cost to purchase the rest of the units .We create n 1 groups of potential anchors , where ith group contains all the anchors of the list i in the generalized knapsack .The group for agent l contains a single element that represents the interval 0 , uj +1 ~ uj ~ , and the associated unit-price pj ~ .This interval represents the excess number of units that can be taken from agent l in iKnapsack f , j , in addition to uj ~ , which has already been committed .In any other group , we can choose at most one anchor .The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem .U is the union of all the tuples in n groups , including a tuple t ~ for agent l .The size of this special tuple is defined as uj +1 ~ uj ~ , and the cost is defined aspj l uj +1 ~ uj ~ .R is the number of units that remain to be acquired .S is the set of tuples accepted in the current tentativetuple is tki , i.e. the kth anchor from agent i .If mark i = 1 , ignore this tuple ; otherwise do the following steps :The approximation algorithm is very similar to the approximation algorithm for knapsack .Since we wish to minimize the total cost , we consider the tuples in order of increasing per unit cost .If the size of tuple tki is smaller than R , then we add it to S , update R , and delete from U all the tuples that belong to the same group as tki .If size tki is greater than R , then S along with tki forms a feasible solution .However , this solution can be far from optimal if the size of tki is much larger than R .If total cost of S and tki is smaller than the current best solution , we update Best .One exception to this rule is the tuple t ~ .Since this tuple can be taken fractionally , we update Best if the sum of S 's cost and fractional cost of t ~ is an improvement .The algorithm terminates in either of the first two cases , or when all tuples are scanned .In particular , it terminates whenever we find a tki such that size tki is greater than R but cost tki is less than cost S , or when we reach the tuple representing agent l and it gives a feasible solution .PROOF .Let V B , j be the value returned by Greedy f , j and let V * B , j be an optimal solution for iKnapsack f , j .Consider the set Skip at the termination of Greedy f , j .There are two cases to consider : either some tuple t E Skip is also in V * B , j , or no tuple in Skip is in V * B , j .In the first case , let St be the tentative solution S at the time t was added to Skip .Because t E Skip then size t > R , and St together with t forms a feasible solution , and we have :In the second case , imagine a modified instance of iKnapsack f , j , which excludes all the tuples of the set Skip .Since none of these tuples were included in V * B , j , the optimal solution for the modified problem should be the same as the one for the original .Suppose our approximation algorithm returns the value V ' B , j for this modified instance .Let t ' be the last tuple considered by the approximation algorithm before termination on the modified instance , and let Sty be the corresponding tentative solution set in that step .Since we consider tuples in order of increasing per unit price , and none of the tuples are going to be placed in the set Skip , we must have cost Sty < V * f , j because Sty is the optimal way to obtain size Sty .We also have cost t ' < cost Sty , and the following inequalities :The inequality V B , j < V ' B , j follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions .Therefore , dropping the tuples in the set Skip can only make the solution worse .The above argument has shown that the value returned by Greedy f , j is within a factor 2 of the optimal solution for iKnapsack f , j .We now show that the value V B , j plus cost tj ~ is a 2-approximation of the original generalized knapsack problem .Let A * be an optimal solution of the generalized knapsack , and suppose that element xj ~ is midrange .Let x_~ to be set of the remaining elements , either zero or anchors , in this solution .Furthermore , define x ' ~ = xj ~ \u2212 uj ~ .Thus ,It is easy to see that x_~ , x ' ~ is an optimal solution for iKnapsack f , j .Since V B , j is a 2-approximation for this optimal solution , we have the following inequalities :This completes the proof of Lemma 2 .It is easy to see that , after an initial sorting of the tuples in U , the algorithm Greedy f , j takes O n time .We have our first polynomial approximation algorithm .PROOF .We run the algorithm Greedy f , j once for each tuple l , j as a candidate for midrange .There are O n tuples , and it suffices to sort them once , the total cost of the algorithm is O n2 .By Lemma 1 , there is an optimal solution with at most one midrange element , so our algorithm will find a 2-approximation , as claimed .The dependence on the number of pieces is also polynomial : if each bid has a maximum of c pieces , then the running time is O nc 2 .We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation FPTAS for the generalized knapsack problem .The high level idea is fairly standard , but the details require technical care .We use a dynamic programming algorithm to solve iKnapsack ~ , j for each possible midrange element , with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming DP table .Consider , for example , the case that the midrange element is x ~ , which falls in the range uj ~ , uj +1 ~ .In our FPTAS , rather than using a greedy approximation algorithm to solve iKnapsack ~ , j , we construct a dynamic programming table to compute the minimum cost at which at least M \u2212 uj +1 ~ units can be obtained using the remaining n \u2212 1 lists in the generalized knapsack .Suppose G i , r denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack .Then , the following recurrence relation describes how to construct the dynamic programming table :where \u03b2 i , r = j : 1 < j < mi , cost tji < r , is the set of anchors for agent i .As convention , agent i will index the row , and cost r will index the column .This dynamic programming algorithm is only pseudo-polynomial , since the number of column in the dynamic programming table depends upon the total cost .However , we can convert it into a FPTAS by scaling the cost dimension .Let A denote the 2-approximation to the generalized knapsack problem , with total cost , cost A .Let \u03b5 denote the desired approximation factor .We compute the scaled cost of a tuple tji , denoted scost tji , asThis scaling improves the running time of the algorithm because the number of columns in the modified table is at most n\u03b5 1 , and independent of the total cost .However , the computed solution might not be an optimal solution for the original problem .We show that the error introduced is within a factor of \u03b5 of the optimal solution .As a prelude to our approximation guarantee , we first show that if two different solutions to the iKnapsack problem have equal scaled cost , then their original unscaled costs can not differ by more than \u03b5cost A .LEMMA 3 .Let x and y be two distinct feasible solutions of iKnapsack ~ , j , excluding their midrange elements .If x and y have equal scaled costs , then their unscaled costs can not differ by more than \u03b5cost A .PROOF .Let Ix and Iy , respectively , denote the indicator functions associated with the anchor vectors x and y there is 1 in position Ix i , k if the xki > 0 .Since x and y has equal scaled cost , However , by 2 , the scaled costs satisfy the following inequalities :Substituting the upper-bound on scaled cost from 4 for cost x , the lower-bound on scaled cost from 4 for cost y , and using equality 3 to simplify , we have :The last inequality uses the fact that at most n components of an indicator vector are non-zero ; that is , any feasible solution contains at most n tuples .Finally , given the dynamic programming table for iKnapsack ~ , j , we consider all the entries in the last row of this table , G n \u2212 1 , r .These entries correspond to optimal solutions with all agents except l , for different levels of cost .In particular , we consider the entries that provide at least M \u2212 uj +1 ~ units .Together with a contribution from agent l , we choose the entry in this set that minimizes the total cost , defined as follows :PROOF .Let x_~ denote the vector of the elements in solution A * without element l. Then , by definition , cost A * = cost + pj ~ xj ~ .Let r = scost be the scaled cost associated with the vector x_~ .Now consider the dynamic programming table constructed for iKnapsack ~ , j , and consider its entry G n \u2212 1 , r .Let A denote the 2-approximation to the generalized knapsack problem , and A l , j denote the solution from the dynamic-programming algorithm .Suppose y _ ~ is the solution associated with this entry in our dynamic program ; the components of the vector y _ ~ are the quantities from different lists .Since both x_~ and y _ ~ have equal scaled costs , by Lemma 3 , their unscaled costs are within \u03b5cost A of each other ; that is ,Now , define yj ~ = max uj ~ , M \u2212 di ~ = ~ j yji ; this is the contribution needed from ~ to make y _ ~ , yj ~ a feasible solution .Among all the equal cost solutions , our dynamic programming tables chooses the one with maximum units .Therefore ,where cost is the original , unscaled cost associated with entry G n \u2212 1 , r .It is worth noting , that unlike the 2-approximation scheme for iKnapsack ~ , j , the value computed with this FPTAS includes the cost to acquire ujl units from l .The following lemma shows that we achieve a 1 + \u03b5 approximation .LEMMA 4 .Suppose A * is an optimal solution of the generalized knapsack problem , and suppose that element l , j is midrange in the optimal solution .Then , the solution A l , j from running the scaled dynamic-programming algorithm on iKnapsack ~ , j satisfies i ~ = ~ k scost tki Ix i , k = scost tki Iy i , k 3 i ~ = ~ yji \u2265 j xj i ~ = ~ k j i ~ = ~ iTherefore , it must be the case that yj ~ < xj ~ .Because yj ~ , y _ ~ is also a feasible solution , if our algorithm returns a solution with cost cost A l , j , then we must havewhere we use the fact that cost A < 2cost A * .Putting this together , our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element l , j , and choose the best solution from among these O n solutions .For a given midrange , the most expensive step in the algorithm is the construction of dynamic programming table , which can be done in O n2 / \u03b5 time assuming constant intervals per list .Thus , we have the following result .The dependence on the number of pieces is also polynomial : if each bid has a maximum of c pieces , then the running time can be derived by substituting cn for each occurrence of n.We now consider the related problem of computing the VCG payments for all the agents .A naive approach requires solving the allocation problem n times , removing each agent in turn .In this section , we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O \u03b1T log \u03b1n / \u03b5 , where 1 < C Z \\ i / C Z < \u03b1 , for a constant upper bound , \u03b1 , and T is the complexity of solving the allocation problem once .This \u03b1-bound can be justified as a `` no monopoly '' condition , because it bounds the marginal value that a single buyer brings to the auction .Similarly , in the reverse variation we can compute the VCG payments to each seller in time O \u03b1T log \u03b1n / \u03b5 , where \u03b1 bounds the ratio C Z \\ i / C Z for all i .Our overall strategy will be to build two dynamic programming tables , forward and backward , for each midrange element l , j once .The forward table is built by considering the agents in the order of their indices , where as the backward table is built by considering them in the reverse order .The optimal solution corresponding to C Z \\ i can be broken into two parts : one corresponding to first i \u2212 1 agents and the other corresponding to last n \u2212 i agents .As the i \u2212 1 th row of the forward table corresponds to the sellers with first i \u2212 1 indices , an approximation to the first part will be contained in i \u2212 1 th row of the forward table .Similarly , n \u2212 i th row of the backward table will contain an approximation for the second part .We first present a simple but an inefficient way of computing the approximate value of C Z \\ i , which illustrates the main idea of our algorithm .Then we present an improved scheme , which uses the fact that the elements in the rows are sorted , to compute the approximate value more efficiently .In the following , we concentrate on computing an allocation with xj ~ being midrange , and some agent i = ~ l removed .This will be a component in computing an approximation to C Z \\ i , the value of the solution to the generalized knapsack without bids from agent i .We begin with the simple scheme .We implement the scaled dynamic programming algorithm for iKnapsack f , j with two alternate orderings over the other sellers , k = ~ l , one with sellers ordered 1 , 2 , ... , n , and one with sellers ordered n , n \u2212 1 , ... , 1 .We call the first table the forward table , and denote it F ~ , and the second table the backward table , and denote it Bl .The subscript f reminds us that the agent f is midrange .9 In building these tables , we use the same scaling factor as before ; namely , the cost of a tuple tji is scaled as follows :where cost A is the upper bound on C Z , given by our 2approximation scheme .In this case , because C Z \\ i can be \u03b1 times C Z , the scaled value of C Z \\ i can be at most n\u03b1 / \u03b5 .Therefore , the cost dimension of our dynamic program 's table will be n\u03b1 / \u03b5 .Now , suppose we want to compute a 1 + e approximation to the generalized knapsack problem restricted to element l , j midrange , and further restricted to remove bids from some seller i = ~ l. Call this problem iKnapsack_i f , j .Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l , all of them either cleared at zero , or on anchors .These first i agents are a different subset of agents in the forward and the backward tables .By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack_i f , j .We consider the row of Fl that corresponds to solutions constructed from agents 1 , 2 , ... , i \u2212 1 , skipping agent l .We consider the row of Bl that corresponds to solutions constructed from agents i +1 , i +2 , ... , n , again skipping agent l .The rows are labeled Fl i \u2212 1 and Bl n \u2212 i respectively .10 The scaled costs for acquiring these units are the column indices for these entries .To solve iKnapsack_i B , j we choose one entry from row F ~ i \u2212 1 and one from row B ~ n \u2212 i such that their total quantity exceeds~ and their combined cost is minimum over all such combinations .Formally , let g G Fl i \u2212 1 , and h G Bl n \u2212 1 denote entries in each row , with size g , size h , denoting the number of units and cost g and cost h denoting the unscaled cost associated with the entry .We compute the following , subjectPROOF .From earlier , we define cost A i = C Z \\ i .We can split the optimal solution , A i , into three disjoint parts : xl corresponds to the midrange seller , xi corresponds to first i 1 sellers skipping agent l if l < i , and x i corresponds to last n i sellers skipping agent l if l > i .We have :Let ri = scost xi and r i = scost x i .Let yi and y i be the solution vectors corresponding to scaled cost ri and r i in F ~ i 1 and B ~ n i , respectively .From Lemma 3 we conclude that ,where cost A is the upper-bound on C Z computed with the 2-approximation .Among all equal scaled cost solutions , our dynamic program chooses the one with maximum units .Therefore we also have , size yi > size xi and size y i > size x i where we use shorthand size x to denote total number of units in all tuples in x. Now , define yjl = max ujl , M size yi size y i .From the preceding inequalities , we have yjl < xjl .Since yjl , yi , y i is also a feasible solution to the generalized knapsack problem without agent i , the value returned by Eq .5 is at mostThis completes the proof .A naive implementation of this scheme will be inefficient because it might check n\u03b1 / E 2 pairs of elements , for any particular choice of l , j and choice of dropped agent i .In the next section , we present an efficient way to compute Eq .5 , and eventually to compute the VCG payments .Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F ~ i 1 and B ~ n i are sorted ; specifically , both , unscaled cost and quantity i.e. size , increases from left to right .As before , let g and h denote generic entries in F ~ i 1 and B ~ n i respectively .To compute Eq .5 , we consider all the tuple pairs , and first divide the tuples that satisfy condition size g + size h >l into two disjoint sets .For each set we compute the best solution , and then take the best between the two sets .We define a pair g , h to be feasible if size g + size h > M ujl .Now to compute Eq .6 , we do a forward and backward walk on F ~ i 1 and B ~ n i respectively .We start from the smallest index of F ~ i 1 and move right , and from the highest index of B ~ n i and move left .Let g , h be the current pair .If g , h is feasible , we decrement B 's pointer that is , move backward otherwise we increment F 's pointer .The feasible pairs found during the walk are used to compute Eq .6 .The complexity of this step is linear in size of F ~ i 1 , which is O n\u03b1 / E .To compute the above equation , we transform the above problem to another problem using modified cost , which is defined as :The modified cost simplifies the problem , but unfortunately the elements in F ~ i 1 and B ~ n i are no longer sorted with respect to mcost .However , the elements are still sorted in quantity and we use this property to compute Eq .7 .Call a pair g , h feasible if M uj +1 l < size g + size h < M ujl .Define the feasible set of g as the elements h E B ~ n i that are feasible given g .As the elements are sorted by quantity , the feasible set of g is a contiguous subset of B ~ n i and shifts left as g increases .l = 50 and M ujl = 60 .Begin and End represent the start and end pointers to the feasible set .Therefore , we can compute Eq .7 by doing a forward and backward walk on F ~ i 1 and B ~ n i respectively .We walk on B ~ n i , starting from the highest index , using two pointers , Begin and End , to indicate the start and end of the current feasible set .We maintain the feasible set as a min heap , where the key is modified cost .To update the feasible set , when we increment F 's pointer move forward , we walk left on B , first using End to remove elements from feasible set which are no longerfeasible and then using Begin to add new feasible elements .For a given g , the only element which we need to consider in g 's feasible set is the one with minimum modified cost which can be computed in constant time with the min heap .So , the main complexity of the computation lies in heap updates .Since , any element is added or deleted at most once , there are O n\u03b1\u03b5 heap updates and the time complexity of this step is O n\u03b1\u03b5 log n\u03b1\u03b5 .The algorithm works as follows .First , using the 2 approximation algorithm , we compute an upper bound on C I .We use this bound to scale down the tuple costs .Using the scaled costs , we build the forward and backward tables corresponding to each tuple l , j .The forward tables are used to compute C I .To compute C I \\ i , we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme .Among all the locally optimal solutions we choose one with the minimum total cost .The most expensive step in the algorithm is computation of C I \\ i .The time complexity of this step is O n2\u03b5\u03b1 log n\u03b1\u03b5 as we have to iterate over all O n choices of tjl , for all l = ~ i , and each time use the above scheme to compute Eq .5 .In the worst case , we might need to compute C I \\ i for all n sellers , in which case the final complexity of the algorithm will be O n3\u03b1It is interesting to recall that T = O n3\u03b5 is the time complexity of the FPTAS to the generalized knapsack problem with all agents .Our combined scheme computes an approximation to the complete VCG mechanism , including payments to O n agents , in time complexity O T log n / \u03b5 , taking the no-monopoly parameter , \u03b1 , as a constant .Thus , our algorithm performs much better than the naive scheme , which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem .The speed up comes from the way we solve iKnapsack \u2212 i B , j .Time complexity of computing iKnapsack \u2212 i B , j by creating a new dynamic programming table will be O n2\u03b5 but by using the forward and backward tables , the complexity is reduced to O n\u03b5 log n\u03b5 .We can further improve the time complexity of our algorithm by computing Eq .5 more efficiently .Currently , the algorithm uses heap , which has logarithmic update time .In worst case , we can have two heap update operations for each element , which makes the time complexity super linear .If we can compute Eq .5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem .", "conclusions": "We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem , using marginal decreasing piecewise constant bidding language .Our scheme is both approximately efficient and approximately strategyproof within any specified factor \u03b5 > 0 .As such it is an example of computationally tractable \u03b5-dominance result , as well as an example of a non-trivial but approximable allocation problem .It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O T log n , where T is the time complexity to compute the solution to a single allocation problem .", "author_keywords_stem": ["approxim algorithm", "multi-unit auction", "strategyproof"], "related work": "There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem , in which there are multiple different items .The combinatorial allocation problem CAP is both NP-complete and inapproximable e.g. 6 .Although some polynomial-time cases have been identified for the CAP 6 , 20 , introducing an expressive exclusive-or bidding language quickly breaks these special cases .We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language the bid taker in our setting is allowed to accept at most one point on the bid curve .The idea of using approximations within mechanisms , while retaining either full-strategyproofness or \u03b5-dominance has received some previous attention .For instance , Lehmann et al. 15 propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem .Nisan & Ronen 18 discussed approximate VCG-based mechanisms , but either appealed to particular maximal-in-range approximations to retain full strategyproofness , or to resource-bounded agents with information or computational limitations on the ability to compute strategies .Feigenminimum-lot size constraints from the buyers .2However , this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism 8 because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome .VCG mechanism do have a natural `` self-correcting '' property , though , because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agent 's own value .baum & Shenker 8 have defined the concept of strategically faithful approximations , and proposed the study of approximations as an important direction for algorithmic mechanism design .Schummer 21 and Parkes et al 19 have previously considered \u03b5-dominance , in the context of economic impossibility results , for example in combinatorial exchanges .Eso et al. 7 have studied a similar procurement problem , but for a different volume discount model .This earlier work formulates the problem as a general mixed integer linear program , and gives some empirical results on simulated data .Kalagnanam et al. 12 address double auctions , where multiple buyers and sellers trade a divisible good .The focus of this paper is also different : it investigates the equilibrium prices using the demand and supply curves , whereas our focus is on efficient mechanism design .Ausubel 1 has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values 1 , with an interpretation as a primal-dual algorithm 2 ."}