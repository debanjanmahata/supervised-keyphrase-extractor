{"abstract": "Machine learning is commonly used to improve ranked retrieval systems .Due to computational difficulties , few learning techniques have been developed to directly optimize for mean average precision MAP , despite its widespread use in evaluating such systems .Existing approaches optimizing MAP either do not find a globally optimal solution , or are computationally expensive .In contrast , we present a general SVM learning algorithm that efficiently finds a globally optimal solution to a straightforward relaxation of MAP .We evaluate our approach using the TREC 9 and TREC 10 Web Track corpora WT10g , comparing against SVMs optimized for accuracy and ROCArea .In most cases we show our method to produce statistically significant improvements in MAP scores .", "id": "H-26", "conclusions": "We have presented an SVM method that directly optimizes MAP .It provides a principled approach and avoids difficult to control heuristics .We formulated the optimization problem and presented an algorithm which provably finds the solution in polynomial time .We have shown empirically that our method is generally superior to or competitive with conventional SVMs methods .Our new method makes it conceptually just as easy to optimize SVMs for MAP as was previously possible only for Accuracy and ROCArea .The computational cost for training is very reasonable in practice .Since other methods typically require tuning multiple heuristics , we also expect to train fewer models before finding one which achieves good performance .The learning framework used by our method is fairly general .A natural extension of this framework would be to develop methods to optimize for other important IR measures , such as Normalized Discounted Cumulative Gain 2 , 3 , 4 , 12 and Mean Reciprocal Rank .", "reader_keywords_stem": ["machin learn", "rank retriev system", "learn techniqu", "mean averag precis", "optim solut", "relax of map", "map relax", "inform retriev system", "probabl", "surrog measur", "loss function", "supervis learn"], "combined_keywords_stem": ["machin learn", "rank retriev system", "learn techniqu", "mean averag precis", "optim solut", "relax of map", "map relax", "inform retriev system", "probabl", "surrog measur", "loss function", "supervis learn", "machin learn for inform retriev", "support vector machin", "rank"], "introduction": "State of the art information retrieval systems commonly use machine learning techniques to learn ranking functions .However , most current approaches do not optimize for the evaluation measure most often used , namely Mean Average Precision MAP .Instead , current algorithms tend to take one of two general approaches .The first approach is to learn a model that estimates the probability of a document being relevant givena query e.g. , 18 , 14 .If solved effectively , the ranking with best MAP performance can easily be derived from the probabilities of relevance .However , achieving high MAP only requires finding a good ordering of the documents .As a result , finding good probabilities requires solving a more difficult problem than necessary , likely requiring more training data to achieve the same MAP performance .The second common approach is to learn a function that maximizes a surrogate measure .Performance measures optimized include accuracy 17 , 15 , ROCArea 1 , 5 , 10 , 11 , 13 , 21 or modifications of ROCArea 4 , and NDCG 2 , 3 .Learning a model to optimize for such measures might result in suboptimal MAP performance .In fact , although some previous systems have obtained good MAP performance , it is known that neither achieving optimal accuracy nor ROCArea can guarantee optimal MAP performance 7 .In this paper , we present a general approach for learning ranking functions that maximize MAP performance .Specifically , we present an SVM algorithm that globally optimizes a hinge-loss relaxation of MAP .This approach simplifies the process of obtaining ranking functions with high MAP performance by avoiding additional intermediate steps and heuristics .The new algorithm also makes it conceptually just as easy to optimize SVMs for MAP as was previously possible only for accuracy and ROCArea .In contrast to recent work directly optimizing for MAP performance by Metzler & Croft 16 and Caruana et al. 6 , our technique is computationally efficient while finding a globally optimal solution .Like 6 , 16 , our method learns a linear model , but is much more efficient in practice and , unlike 16 , can handle many thousands of features .We now describe the algorithm in detail and provide proof of correctness .Following this , we provide an analysis of running time .We finish with empirical results from experiments on the TREC 9 and TREC 10 Web Track corpus .We have also developed a software package implementing our algorithm that is available for public user .", "evaluation": "For each dataset in Table 5 , we performed 50 trials .For each trial , we train on 10 randomly selected queries , and select another 5 queries at random for a validation set .Models were trained using a wide range of C values .The model which performed best on the validation set was selected and tested on the remaining 35 queries .All queries were selected to be in the training , validation and test sets the same number of times .Using this setup , we performed the same experiments while using our method SVM\u0394map , an SVM optimizing for ROCArea SVM\u0394 roc 13 , and a conventional classification SVM SVMacc 20 .All SVM methods used a linear kernel .We reported the average performance of all models over the 50 trials .In analyzing our results , the first question to answer is , can SVM\u0394map learn a model which outperforms the best basefunctions ?Table 6 presents the comparison of SVM\u0394 map with the best Indri base functions .Each column group contains the macro-averaged MAP performance of SVM\u0394map or a base function .The W/L columns show the number of queries where SVM\u0394 map achieved a higher MAP score .Significance tests were performed using the two-tailed Wilcoxon signed rank test .Two stars indicate a significance level of 0.95 .All tables displaying our experimental results are structured identically .Here , we find that SVM\u0394 map significantly outperforms the best base functions .Table 7 shows the comparison when trained on TREC submissions .While achieving a higher MAP score than the best base functions , the performance difference between SVM\u0394map the base functions is not significant .Given that many of these submissions use scoring functions which are carefully crafted to achieve high MAP , it is possible that the best performing submissions use techniques which subsume the techniques of the other submissions .As a result , SVM\u0394map would not be able to learn a hypothesis which can significantly out-perform the best submission .Hence , we ran the same experiments using a modified dataset where the features computed using the best submission were removed .Table 8 shows the results note that we are still comparing against the best submission though we are not using it for training .Notice that while the performance of SVM\u0394 map degraded slightly , the performance was still comparable with that of the best submission .The next question to answer is , does SVM\u0394map produce higher MAP scores than previous SVM methods ?Tables 9 and 10 present the results of SVM\u0394 map , SVM\u0394 roc , and SVMacc when trained on the Indri retrieval functions and TREC submissions , respectively .Table 11 contains the corresponding results when trained on the TREC submissions without the best submission .To start with , our results indicate that SVMacc was not competitive with SVM\u0394map and SVM\u0394 roc , and at times underperformed dramatically .As such , we tried several approaches to improve the performance of SVMacc .One issue which may cause SVMacc to underperform is the severe imbalance between relevant and non-relevant documents .The vast majority of the documents are not relevant .SVMacc2 addresses this problem by assigning more penalty to false negative errors .For each dataset , the ratio of the false negative to false positive penalties is equal to the ratio of the number non-relevant and relevant documents in that dataset .Tables 9 , 10 and 11 indicate that SVMacc2 still performs significantly worse than SVM\u0394 map .Another possible issue is that SVMacc attempts to find just one discriminating threshold b that is query-invariant .It may be that different queries require different values of b. Having the learning method trying to find a good b value when one does not exist may be detrimental .We took two approaches to address this issue .The first method , SVMacc3 , converts the retrieval function scores into percentiles .For example , for document d , query q and retrieval function f , if the score f dlq is in the top 90 % of the scores f \u2022 lq for query q , then the converted score is f ' dlq = 0.9 .Each Kf contains 50 evenly spaced values between 0 and 1 .Tables 9 , 10 and 11 show that the performance of SVMacc3 was also not competitive with SVM\u0394map .The second method , SVMacc4 , normalizes the scores given by f for each query .For example , assume for query q that f outputs scores in the range 0.2 to 0.7 .Then for document d , if f dlq = 0.6 , the converted score would be f ' dlq = 0.6 0.2 / 0.7 0.2 = 0.8 .Each Kf contains 50 evenly spaced values between 0 and 1 .Again , Tables 9 , 10 and 11 show that SVMacc4 was not competitive with SVM\u0394mapSVM\u0394 roc performed much better than SVMacc in our experiments .When trained on Indri retrieval functions see Table 9 , the performance of SVM\u0394 roc was slight , though not significantly , worse than the performances of SVM\u0394map .However , Table 10 shows that SVM\u0394 map did significantly outperform SVM\u0394 roc when trained on the TREC submissions .Table 11 shows the performance of the models when trained on the TREC submissions with the best submission removed .The performance of most models degraded by a small amount , with SVM\u0394 map still having the best performance .", "method": "Following the standard machine learning setup , our goal is to learn a function h : X + Y between an input space X all possible queries and output space Y rankings over a corpus .In order to quantify the quality of a prediction , y\u02c6 = h x , we will consider a loss function \u0394 : Y x Y + R. \u0394 y , \u02c6y quantifies the penalty for making prediction y\u02c6 if the correct output is y .The loss function allows us to incorporate specific performance measures , which we will exploitfor optimizing MAP .We restrict ourselves to the supervised learning scenario , where input/output pairs x , y are available for training and are assumed to come from some fixed distribution P x , y .The goal is to find a function h such that the risk i.e. , expecis minimized .Of course , P x , y is unknown .But given a finite set of training pairs , S = xi , yi \u2208 X \u00d7 Y : i = 1 , ... , n , the performance of h on S can be measured by the empirical risk , \u0394 yi , h xi .In the case of learning a ranked retrieval function , X denotes a space of queries , and Y the space of possibly weak rankings over some corpus of documents C = d1 , ... , d | C | .We can define average precision loss aswhere rank y is a vector of the rank values of each document in C. For example , for a corpus of two documents , d1 , d2 , with d1 having higher rank than d2 , rank y ' = 1 , 0 .We assume true rankings have two rank values , where relevant documents have rank value 1 and non-relevant documents rank value 0 .We further assume that all predicted rankings are complete rankings no ties .Let p = rank y and p\u02c6 = rank \u02c6y .The average precision score is defined as two hypotheses predict a ranking for query x over a corpus of eight documents .Table 2 shows the MAP and ROCArea scores of h1 and h2 .Here , a learning method which optimizes for ROCArea would choose h2 since that results in a higher ROCArea score , but this yields a suboptimal MAP score .Using a very similar example , we now demonstrate how optimizing for accuracy might result in suboptimal MAP .Models which optimize for accuracy are not directly concerned with the ranking .Instead , they learn a threshold such that documents scoring higher than the threshold can be classified as relevant and documents scoring lower as nonrelevant .where rel = | i : pi = 1 | is the number of relevant documents , and Prec@j is the percentage of relevant documents in the top j documents in predicted ranking \u02c6y .MAP is the mean of the average precision scores of a group of queries .Most learning algorithms optimize for accuracy or ROCArea .While optimizing for these measures might achieve good MAP performance , we use two simple examples to show it can also be suboptimal in terms of MAP .ROCArea assigns equal penalty to each misordering of a relevant/non-relevant pair .In contrast , MAP assigns greater penalties to misorderings higher up in the predicted ranking .Using our notation , ROCArea can be defined aswhere p is the true weak ranking , p\u02c6 is the predicted ranking , and 1 b is the indicator function conditioned on b.Suppose we have a hypothesis space with only two hypothesis functions , h1 and h2 , as shown in Table 1 .TheseTable 4 shows the MAP and best accuracy scores of h1 q and h2 q .The best accuracy refers to the highest achievable accuracy on that ranking when considering all possible thresholds .For instance , with h1 q , a threshold between documents 1 and 2 gives 4 errors documents 6-9 incorrectly classified as non-relevant , yielding an accuracy of 0.64 .Similarly , with h2 q , a threshold between documents 5 and 6 gives 3 errors documents 10-11 incorrectly classified as relevant , and document 1 as non-relevant , yielding an accuracy of 0.73 .A learning method which optimizes for accuracy would choose h2 since that results in a higher accuracy score , but this yields a suboptimal MAP score .We build upon the approach used by 13 for optimizing ROCArea .Unlike ROCArea , however , MAP does not decompose linearly in the examples and requires a substantially extended algorithm , which we describe in this section .Recall that the true ranking is a weak ranking with two rank values relevant and non-relevant .Let Cx and C \u00af x denote the set of relevant and non-relevant documents of C for query x , respectively .We focus on functions which are parametrized by a weight vector w , and thus wish to find w to minimize the empirical risk , R\u0394S w \u2261 R\u0394S h \u00b7 ; w .Our approach is to learn a discriminant function F : X \u00d7 Y \u2192 < over input-output pairs .Given query x , we can derive a prediction by finding the ranking y that maximizes the discriminant function :We assume F to be linear in some combined feature representation of inputs and outputs \u03a8 x , y \u2208 RN , i.e. ,where \u03c6 : X \u00d7 C \u2192 < N is a feature mapping function from a query/document pair to a point in N dimensional space2 .We represent rankings as a matrix of pairwise orderings , Y \u2282 \u2212 1 , 0 , +1 1c1x1c1 .For any y \u2208 Y , yij = +1 if di is ranked ahead of dj , and yij = \u2212 1 if dj is ranked ahead of di , and yij = 0 if di and dj have equal rank .We consider only matrices which correspond to valid rankings i.e , obeying antisymmetry and transitivity .Intuitively , \u03a8 is a summation over the vector differences of all relevant/non-relevant document pairings .Since we assume predicted rankings to be complete rankings , yij is either +1 or \u2212 1 never 0 .Given a learned weight vector w , predicting a ranking i.e. solving equation 1 given query x reduces to picking each yij to maximize wT \u03a8 x , y .As is also discussed in 13 , this is attained by sorting the documents by wT \u03c6 x , d in descending order .We will discuss later the choices of \u03c6 we used for our experiments .The above formulation is very similar to learning a straightforward linear model while training on the pairwise difference of relevant/non-relevant document pairings .Many SVM-based approaches optimize over these pairwise differences e.g. , 5 , 10 , 13 , 4 , although these methods do not optimize for MAP during training .Previously , it was not clear how to incorporate non-linear multivariate loss functions such as MAP loss directly into global optimization problems such as SVM training .We now present a method based on structural SVMs 19 to address this problem .We use the structural SVM formulation , presented in Optimization Problem 1 , to learn a w \u2208 RN .The objective function to be minimized 3 is a tradeoff between model complexity , kwk2 , and a hinge loss relaxation of MAP loss , E \u03bei .As is usual in SVM training , C is a 2For example , one dimension might be the number of times the query words appear in the document .Algorithm 1 Cutting plane algorithm for solving OP 1 within tolerance ~ .parameter that controls this tradeoff and can be tuned to achieve good performance in different training tasks .For each xi , yi in the training set , a set of constraints of the form in equation 4 is added to the optimization problem .Note that wT \u03a8 x , y is exactly our discriminant function F x , y ; w see equation 2 .During prediction , our model chooses the ranking which maximizes the discriminant 1 .If the discriminant value for an incorrect ranking y is greater than for the true ranking yi e.g. , F xi , y ; w > F xi , yi ; w , then corresponding slack variable , \u03bei , must be at least \u0394 yi , y for that constraint to be satisfied .Therefore , the sum of slacks , E \u03bei , upper bounds the MAP loss .This is stated formally in Proposition 1 .PROPOSITION 1 .Let \u03be * w be the optimal solution of the slack variables for OP 1 for a given weight vector w. Thensee 19 for proof Proposition 1 shows that OP 1 learns a ranking function that optimizes an upper bound on MAP error on the training set .Unfortunately there is a problem : a constraint is required for every possible wrong output y , and the number of possible wrong outputs is exponential in the size of C. Fortunately , we may employ Algorithm 1 to solve OP 1 .Algorithm 1 is a cutting plane algorithm , iteratively introducing constraints until we have solved the original problem within a desired tolerance ~ 19 .The algorithm starts with no constraints , and iteratively finds for each example xi , yi the output y\u02c6 associated with the most violated constraint .If the corresponding constraint is violated by more than ~ we introduce y\u02c6 into the working set Wi of active constraints for example i , and re-solve 3 using the updated W .It can be shown that Algorithm 1 's outer loop is guaranteed to halt within a polynomial number of iterations for any desired precision ~ .THEOREM 1 .Let R \u00af = maxi maxy k\u03a8 xi , yi \u2212 \u03a8 xi , y k , \u0394 \u00af = maxi maxy \u0394 yi , y , and for any ~ > 0 , Algorithm 1 terminates after adding at mostconstraints to the working set W. see 19 for proof However , within the inner loop of this algorithm we haveto compute argmaxY \u2208 Y H y ; w , where H y ; w = \u0394 yi , y + wT \u03a8 xi , y \u2212 wT \u03a8 xi , yi , or equivalently , documents ranked before it , as opposed to j \u2212 1 .The second term is the change in the discriminant score , wT \u03a8 x , y , when yij changes from +1 to \u2212 1 .argmax \u0394 yi , y + wT \u03a8 xi , y , ... , dxi , dj , dx Y \u2208 Y x i +1 , ... ... , d \u00af xj , dxi , dxi +1 , ... since wT \u03a8 xi , yi is constant with respect to y. Though closely related to the classification procedure , this has the substantial complication that we must contend with the additional \u0394 yi , y term .Without the ability to efficiently find the most violated constraint i.e. , solve argmaxY \u2208 Y H y , w , the constraint generation procedure is not tractable .Using OP 1 and optimizing to ROCArea loss \u0394roc , the problem of finding the most violated constraint , or solving argmaxY \u2208 Y H y , w henceforth argmax H , is addressed in 13 .Solving argmax H for \u0394map is more difficult .This is primarily because ROCArea decomposes nicely into a sum of scores computed independently on each relative ordering of a relevant/non-relevant document pair .MAP , on the other hand , does not decompose in the same way as ROCArea .The main algorithmic contribution of this paper is an efficient method for solving argmax H for \u0394map .One useful property of \u0394map is that it is invariant to swapping two documents with equal relevance .For example , if documents da and db are both relevant , then swapping the positions of da and db in any ranking does not affect \u0394map .By extension , \u0394map is invariant to any arbitrary permutation of the relevant documents amongst themselves and of the non-relevant documents amongst themselves .However , this reshuffling will affect the discriminant score , wT \u03a8 x , y .This leads us to Observation 1 .OBSERVATION 1 .Consider rankings which are constrained by fixing the relevance at each position in the ranking e.g. , the 3rd document in the ranking must be relevant .Every ranking which satisfies the same set of constraints will have the same \u0394map .If the relevant documents are sorted by wT \u03c6 x , d in descending order , and the non-relevant documents are likewise sorted by wT \u03c6 x , d , then the interleaving of the two sorted lists which satisfies the constraints will maximize H for that constrained set of rankings .Observation 1 implies that in the ranking which maximizes H , the relevant documents will be sorted by wT \u03c6 x , d , and the non-relevant documents will also be sorted likewise .By first sorting the relevant and non-relevant documents , the problem is simplified to finding the optimal interleaving of two sorted lists .For the rest of our discussion , we assume that the relevant documents and non-relevant documents are both sorted by descending wT \u03c6 x , d .For convenience , we also refer to relevant documents as dx1 , ... dx | Cs | = Cx , and non-relevant documents as dx 1 , ... d | C \u00af s | = C x \u00af x .We define \u03b4j i1 , i2 , with i1 < i2 , as the change in H from when the highest ranked relevant document ranked after d \u00af xj is dx i1 to when it is dx i2 .For i2 = i1 + 1 , we havewhere si = wT \u03c6 x , di .The first term in 5 is the change in \u0394map when the ith relevant document has j non-relevantFigure 1 gives a conceptual example for \u03b4j i , i + 1 .The bottom ranking differs from the top only where d \u00af xj slides up one rank .The difference in the value of H for these two rankings is exactly \u03b4j i , i + 1 .For any i1 < i2 , we can then define \u03b4j i1 , i2 asLet o1 , ... , o | C \u00af s | encode the positions of the non-relevant documents , where dxog is the highest ranked relevant document ranked after the jth non-relevant document .Due to Observation 1 , this encoding uniquely identifies a complete ranking .We can recover the ranking aswhere y \u00af is the true weak ranking .Conceptually H0 starts with a perfect ranking \u00af y , and adds the change in H when each successive non-relevant document slides up the ranking .We can then reformulate the argmax H problem asAlgorithm 2 describes the algorithm used to solve equation 8 .Conceptually , Algorithm 2 starts with a perfect ranking .Then for each successive non-relevant document , the algorithm modifies the solution by sliding that document up the ranking to locally maximize H0 while keeping the positions of the other non-relevant documents constant .Algorithm 2 is greedy in the sense that it finds the best position of each non-relevant document independently from the other non-relevant documents .In other words , the algorithm maximizes H0 for each non-relevant document , d \u00af xj ,Algorithm 2 Finding the Most Violated Constraint argmax H for Algorithm 1 with \u0394mapwithout considering the positions of the other non-relevant documents , and thus ignores the constraints of 9 .In order for the solution to be feasible , the jth non-relevant document must be ranked after the first j \u2212 1 non-relevant documents , thus satisfyingIf the solution is feasible , the it clearly solves 8 .Therefore , it suffices to prove that Algorithm 2 satisfies 10 .We first prove that \u03b4j \u00b7 , \u00b7 is monotonically decreasing in j. LEMMA 1 .For any 1 \u2264 i1 < i2 \u2264 | Cx | + 1 and 1 \u2264 j < | C \u00af x | , it must be the case thatPROOF .Recall from 6 that both \u03b4j i1 , i2 and \u03b4j +1 i1 , i2 are summations of i2 \u2212 i1 terms .We will show that each term in the summation of \u03b4j +1 i1 , i2 is no greater than the corresponding term in \u03b4j i1 , i2 , orfor k = i1 , ... , i2 \u2212 1 .Each term in \u03b4j k , k + 1 and \u03b4j +1 k , k + 1 can be further decomposed into two parts see 5 .We will show that each part of \u03b4j +1 k , k + 1 is no greater than the corresponding part in \u03b4j k , k + 1 .In other words , we will show that both andare true for the aforementioned values of j and k .It is easy to see that 11 is true by observing that for any two positive integers 1 \u2264 a < b ,and choosing a = j and b = j + k .The second inequality 12 holds because Algorithm 2 first sorts d \u00af x in descending order of s \u00af x , implying s \u00af xj +1 \u2264 s j .\u00af x Thus we see that each term in \u03b4j +1 is no greater than the corresponding term in \u03b4j , which completes the proof .The result of Lemma 1 leads directly to our main correctness result : THEOREM 2 .In Algorithm 2 , the computed values of optj satisfy 10 , implying that the solution returned by Algorithm 2 is feasible and thus optimal .PROOF .We will prove thatwhich contradicts 13 .Therefore , it must be the case that optj \u2264 optj +1 , which completes the proof .The running time of Algorithm 2 can be split into two parts .The first part is the sort by wT \u03c6 x , d , which requires O n log n time , where n = | Cx | + | C \u00af x | .The second part computes each optj , which requires O | Cx | \u00b7 | C \u00af x | time .Though in the worst case this is O n2 , the number of relevant documents , | Cx | , is often very small e.g. , constant with respect to n , in which case the running time for the second part is simply O n .For most real-world datasets , Algorithm 2 is dominated by the sort and has complexity O n log n .Algorithm 1 is guaranteed to halt in a polynomial number of iterations 19 , and each iteration runs Algorithm 2 .Virtually all well-performing models were trained in a reasonable amount of time usually less than one hour .Once training is complete , making predictions on query x using the resulting hypothesis h x | w requires only sorting by wT \u03c6 x , d .We developed our software using a Python interface3 to SVMstruct , since the Python language greatly simplified the coding process .To improve performance , it is advisable to use the standard C implementation4 of SVMstruct .The main goal of our experiments is to evaluate whether directly optimizing MAP leads to improved MAP performance compared to conventional SVM methods that optimize a substitute loss such as accuracy or ROCArea .We empirically evaluate our method using two sets of TREC Web Track queries , one each from TREC 9 and TREC 10 topics 451-500 and 501-550 , both of which used the WT10g corpus .For each query , TREC provides the relevance judgments of the documents .We generated our features using the scores of existing retrieval functions on these queries .While our method is agnostic to the meaning of the features , we chose to use existing retrieval functions as a simple yet effective way of acquiring useful features .As such , ourexperiments essentially test our method 's ability to re-rank the highly ranked documents e.g. , re-combine the scores of the retrieval functions to improve MAP .We compare our method against the best retrieval functions trained on henceforth base functions , as well as against previously proposed SVM methods .Comparing with the best base functions tests our method 's ability to learn a useful combination .Comparing with previous SVM methods allows us to test whether optimizing directly for MAP as opposed to accuracy or ROCArea achieves a higher MAP score in practice .The rest of this section describes the base functions and the feature generation method in detail .We chose two sets of base functions for our experiments .For the first set , we generated three indices over the WT10g corpus using Indri5 .The first index was generated using default settings , the second used Porter-stemming , and the last used Porter-stemming and Indri 's default stopwords .For both TREC 9 and TREC 10 , we used the description portion of each query and scored the documents using five of Indri 's built-in retrieval methods , which are Cosine Similarity , TFIDF , Okapi , Language Model with Dirichlet Prior , and Language Model with Jelinek-Mercer Prior .All parameters were kept as their defaults .We computed the scores of these five retrieval methods over the three indices , giving 15 base functions in total .For each query , we considered the scores of documents found in the union of the top 1000 documents of each base function .For our second set of base functions , we used scores from the TREC 9 8 and TREC 10 9 Web Track submissions .We used only the non-manual , non-short submissions from both years .For TREC 9 and TREC 10 , there were 53 and 18 such submissions , respectively .A typical submission contained scores of its top 1000 documents .In order to generate input examples for our method , a concrete instantiation of \u03c6 must be provided .For each document d scored by a set of retrieval functions F on query x , we generate the features as a vector \u03c6 x , d = 1 f djx > k : ` df 2 F , ` dk 2 Kf , where f djx denotes the score that retrieval function f assigns to document d for query x , and each Kf is a set of real values .From a high level , we are expressing the score of each retrieval function using jKf j + 1 bins .Since we are using linear kernels , one can think of the learning problem as finding a good piecewise-constant combination of the scores of the retrieval functions .Figure 2 shows an example of our feature mapping method .In this example we have a single feature F = f .Here , Kf = a , b , c , and the weight vector is w = wa , wb , wc .For any document d and query x , we haveThis is expressed qualitatively in Figure 2 , where wa and wb are positive , and wc is negative .We ran our main experiments using four choices of F : the set of aforementioned Indri retrieval functions for TREC 9 and TREC 10 , and the Web Track submissions for TREC 9 and TREC 10 .For each F and each function f 2 F , we chose 50 values for Kf which are reasonably spaced and capture the sensitive region of f. Using the four choices of F , we generated four datasets for our main experiments .Table 5 contains statistics of the generated datasets .There are many ways to generate features , and we are not advocating our method over others .This was simply an efficient means to normalize the outputs of different functions and allow for a more expressive model .", "title": "A Support Vector Method for Optimizing Average Precision", "author_keywords_stem": ["machin learn for inform retriev", "support vector machin", "rank"]}